unit Int64unit;

?@nodisplay := true;
?@noalignstack := true;
?@leave := true;

type
	real80_t:
		record
			r	:real80;
			pad	:byte[6];
		endrecord;
		
const
	#if( @defined( unix ) )
	
		cPrefix :text := """""";
		nls :string := #$a;
		nl :text := nls;
		
	#elseif( @defined( macosx ))
	
		cPrefix :text := """_""";
		nls :string := #$a;
		nl :text := nls;
		
	#else
	
		cPrefix :text := """_""";
		nls :string := #$d #$a;
		nl :text := nls;
		
	#endif

static

	// The symbol table entries in the C code:
	
	boolean_ste: byte; 	@external( cPrefix "boolean_ste" );	
	
	//enum_ste: byte; 	@external( cPrefix "enum_ste" );		
	
	uns8_ste: byte; 	@external( cPrefix "uns8_ste" );		
	uns16_ste: byte;	@external( cPrefix "uns16_ste" );		
	uns32_ste: byte;	@external( cPrefix "uns32_ste" );		
	uns64_ste: byte;	@external( cPrefix "uns64_ste" );		
	uns128_ste: byte;	@external( cPrefix "uns128_ste" );	
	
	byte_ste: byte;		@external( cPrefix "byte_ste" );		
	word_ste: byte;		@external( cPrefix "word_ste" );		
	dword_ste: byte;	@external( cPrefix "dword_ste" );		
	qword_ste: byte;	@external( cPrefix "qword_ste" );		
	tbyte_ste: byte;	@external( cPrefix "tbyte_ste" );		
	lword_ste: byte;	@external( cPrefix "lword_ste" );		

	int8_ste: byte;		@external( cPrefix "int8_ste" );		
	int16_ste: byte;	@external( cPrefix "int16_ste" );		
	int32_ste: byte;	@external( cPrefix "int32_ste" );		
	int64_ste: byte;	@external( cPrefix "int64_ste" );		
	int128_ste: byte;	@external( cPrefix "int128_ste" );	

	char_ste: byte;		@external( cPrefix "char_ste" ); 		
	wchar_ste: byte;	@external( cPrefix "wchar_ste" );		

	real32_ste: byte;	@external( cPrefix "real32_ste" );	
	real64_ste: byte;	@external( cPrefix "real64_ste" ); 	
	real80_ste: byte;	@external( cPrefix "real80_ste" );	
	real128_ste: byte;	@external( cPrefix "real128_ste" );	
	  
	string_ste: byte;	@external( cPrefix "string_ste" );	
	zstring_ste: byte;	@external( cPrefix "zstring_ste" );	
	wstring_ste: byte;	@external( cPrefix "wstring_ste" );	
	cset_ste: byte;		@external( cPrefix "cset_ste" );
	
	EnumSize	:dword;	@external( cPrefix "EnumSize" );
	ProcGlobal	:dword; @external( cPrefix "ProcGlobal" );
	parmLookup	:boolean; @external( cPrefix "parmLookup" );		

		
type

	// Note: The following have to be kept in sync with
	//			the C declarations in enum.h (fortunately,
	//			the syntax for the body is the same as for
	//			C, so it's just a cut and paste job.
	pType:	enum
			{ 

				tBoolean,	//0 
				tEnum,		//1
				
				tUns8,		//2
				tUns16,		//3
				tUns32,		//4
				tUns64,		//5
				tUns128,	//6
				
				_tByte,		//7
				tWord,		//8
				tDWord,		//9
				tQWord,		//10
				tTByte,		//11
				tLWord,		//12

				tInt8,		//13
				tInt16,		//14
				tInt32,		//15
				tInt64,		//16
				tInt128,	//17

				tChar, 		//18
				tWChar,		//19

				tReal32,	//20
				tReal64, 	//21
				tReal80,	//22
				tReal128,	//23
				 
				tString,	//24
				tZString,	//25
				tWString,	//26
				tCset,		//27

				tArray,		//28
				tRecord,	//29
				tUnion,		//30
				tRegex,		//31
				tClass,		//32
				tProcptr,	//33
				tThunk,		//34
				tPointer,	//35


				tLabel,		//36
				tProc,		//37
				tMethod,	//38
				tClassProc,	//39
				tClassIter, //40
				tIterator,	//41
				tProgram,	//42
				tMacro,		//43
				tOverload,	//44
				tText,		//45
				tRegexMac,	//46
							
				tNamespace,	//47
				tSegment,   //48
				tAnonRec,	//49
				tAnonUnion,	//50
				tVariant,	//51
				tError		//52	Used to denote a cascading error.
			};
	
	//  A symbol table entry in the C code (well, at least the
	// fields that this code needs):
	
	SymNode	:record
	
		Next			:dword;	  //	struct	SymNode		*Next;
		hashList		:dword;	  //	struct	SymNode		*hashList;
		lcName			:dword;	  //	char				*Name;
		TrueName		:dword;	  //	char				*TrueName;
		NameLen			:dword;	  //	int					NameLen;
		symType			:dword;	  //	struct	SymNode		*Type;
		pType			:dword;	  //	enum	PrimType	pType;
		symClass		:dword;	  //	enum	ClassType	SymClass;
		pClass			:dword;	  //	enum	ParmClass	pClass;
		objectSize		:dword;	  //	unsigned			ObjectSize;
		MaxObjectSize	:dword;	  //	unsigned			MaxObjectSize;
		offset			:dword;	  //	int					Offset;
		StaticName		:dword;	  //	char				*StaticName;
		LexLevel		:dword;	  //	int					LexLevel;
		
		// There's more, but this code doesn't use it.
				
	endrecord;
	














	
static

	saveESP	:dword;			// Kludge for MacOSX.
	
	
	// The following table maps pTypes to Types:
	
	typeTable :dword[ byte(tCset) + 1] :=
		[
			&boolean_ste,	
			&boolean_ste,	// No symbol table type for enum!		

			&uns8_ste,		
			&uns16_ste,		
			&uns32_ste,		
			&uns64_ste,		
			&uns128_ste,	
			
			&byte_ste,		
			&word_ste,		
			&dword_ste,		
			&qword_ste,
			&tbyte_ste,		
			&lword_ste,		

			&int8_ste,		
			&int16_ste,		
			&int32_ste,		
			&int64_ste,		
			&int128_ste,	

			&char_ste, 		
			&wchar_ste,		

			&real32_ste,	
			&real64_ste, 	
			&real80_ste,
			&real128_ste,	
			 
			&string_ste,
			&zstring_ste,	
			&wstring_ste,	
			&cset_ste		
		];


// Interface to the C code to allow printing error messages during compilation.

procedure HLAerror
( 
	msg:string;
	line:int32;
	file:string 
); 
	@cdecl; 
	@external( cPrefix "HLAerror" );
	
val
	linenum:int32;
	filename:string;
	
const
	yyerror :text := "?linenum:=@linenumber; ?filename:=@filename; HLAerr";
	
#macro HLAerr( msg );
	returns
	({
		push( ebx );		// For mac, call must have
		mov( esp, ebx );	// rtn adrs aligned on a
		sub( 28, esp );		// 16-byte boundary.
		and( $ffff_fff0, esp );
		HLAerror( msg, linenum, filename );
		mov( ebx, esp );
		pop( ebx );
	}, "" )		
#endmacro;
	
	


// The following cheesy macros and procedure exist mainly for
// debug purposes.  The 'printf' macro is a simulation of the
// C/C++ printf function (though it currently allows a maximum
// of two values to print).  This code doesn't normally call this
// function except to display debug messages.  Note that we cannot
// call HLA StdLib routines from this code since it links with
// C/C++.
	
procedure printf1( fmt:string; v:dword ); @cdecl; @external( cPrefix "printf" );
procedure printf2
( 
	fmt:string; 
	v1:dword;
	v2:dword 
); 
	@cdecl; 
	@external( cPrefix "printf" );

procedure printff
( 
	fmt:string 
); 
	@cdecl; 
	@external( cPrefix "printf" );

#macro printf( fmt, args[] );
	
	pushad();
	mov( esp, saveESP );		// For mac, call must have
	sub( 32, esp );				// stack aligned on a 
	and( $ffff_fff0, esp );		// 16-byte boundary at call.
	
	#if( @elements( args ) = 1 )
	
		#if( @typename( @text( args[0] )) = "real32" )
		
			add( 4, esp );
			fld( @text( args[0] ) );
			fstp( (type real64 [esp]));
			printff( fmt + #$d + #$a );
		
		
		#elseif( @typename( @text( args[0] )) = "real64" )
		
			add( 4, esp );
			fld( @text( args[0] ) );
			fstp( (type real64 [esp]));
			printff( fmt + #$d + #$a );
		
		#else
		
			add( 8, esp );
			printf1( fmt + #$d + #$a, @text( args[0] ) );
			
		#endif
		
	#elseif( @elements( args ) = 2 )

	
		add( 12, esp );
		printf2( fmt + #$d + #$a, @text( args[0] ), @text( args[1] ) );
	
	#else
	
		#error( "unexpected # of arguments to printf" )
		
	#endif
	mov( saveESP, esp );
	popad();
	
#endmacro;




// Another C/C++ interface routine.
// Calls the HLA compiler's malloc2 function
// (which is malloc plus an assert that checks for NULL return).
//
// This code saves all the important register (sans EAX) because
// we don't know what C compiler we're linking with.
// Assumes ESP and EBP are okay and that the return result is in EAX.

procedure _HLAmalloc( size:dword ); @cdecl; @external( cPrefix "HLAmalloc" );

#macro malloc2( s );
	push( esi );
	push( edi );
	push( ebx );
	push( ecx );
	push( edx );
	
	_HLAmalloc( s );
	add( 4, esp );
	
	pop( edx );
	pop( ecx );
	pop( ebx );
	pop( edi );
	pop( esi );
#endmacro;






// The following should probably be in a header file.
// However, as this is the only file that uses them, may as well
// put them here.  These "external" declarations exist mainly
// so we can export all these symbols to the C code.
//
//	Note: for Borland C++, 'cPrefix' must expand to a string
// containing an underscore.  For GCC, 'cPrefix' must expand
// to an empty string.


procedure atold( s:string; var dest:real80 ); @external( cPrefix "atold" );
procedure e80Str( r80:real80_t; buffer:dword ); @external( cPrefix "e80Str" );

procedure fadd80( r:real80_t; l:real80_t; var f:real80 ); @external( cPrefix "fadd80" );
procedure fsub80( r:real80_t; l:real80_t; var f:real80 ); @external( cPrefix "fsub80" );
procedure fmul80( r:real80_t; l:real80_t; var f:real80 ); @external( cPrefix "fmul80" );
procedure fdiv80( r:real80_t; l:real80_t; var f:real80 ); @external( cPrefix "fdiv80" );

procedure fneg80( l:real80_t; var f:real80 ); @external( cPrefix "fneg80" );
procedure fabs80( l:real80_t; var f:real80 ); @external( cPrefix "fabs80" );

procedure fmax80( r:real80_t; l:real80_t; var f:real80 ); @external( cPrefix "fmax80" );
procedure fmin80( r:real80_t; l:real80_t; var f:real80 ); @external( cPrefix "fmin80" );

procedure feq80 ( r:real80_t; l:real80_t ); @external( cPrefix "feq80" );
procedure fne80 ( r:real80_t; l:real80_t ); @external( cPrefix "fne80" );
procedure flt80 ( r:real80_t; l:real80_t ); @external( cPrefix "flt80" );
procedure fle80 ( r:real80_t; l:real80_t ); @external( cPrefix "fle80" );
procedure fgt80 ( r:real80_t; l:real80_t ); @external( cPrefix "fgt80" );
procedure fge80 ( r:real80_t; l:real80_t ); @external( cPrefix "fge80" );

procedure f80int ( src:real80_t; var dest:var ); 
	@cdecl;
	@external( cPrefix "f80int" );
	
procedure unsf80 ( var src:var; var f:real80 ); 
	@cdecl;
	@external( cPrefix "unsf80" );

procedure ceil80( src:real80_t; var dest:real80 ); @external( cPrefix "ceil80" );
procedure floor80( src:real80_t; var dest:real80 ); @external( cPrefix "floor80" );
procedure cos80( src:real80_t; var dest:real80 ); @external( cPrefix "cos80" );
procedure sin80( src:real80_t; var dest:real80 ); @external( cPrefix "sin80" );
procedure tan80( src:real80_t; var dest:real80 ); @external( cPrefix "tan80" );
procedure exp80( src:real80_t; var dest:real80 ); @external( cPrefix "exp80" );
procedure log80( src:real80_t; var dest:real80 ); @external( cPrefix "log80" );
procedure log1080( src:real80_t; var dest:real80 ); @external( cPrefix "log1080" );
procedure sqrt80( src:real80_t; var dest:real80 ); @external( cPrefix "sqrt80" );

procedure negval
( 
	var dest	:var;
	var	src		:var;
		vpt		:pType;
	var	vpta	:pType;
		vt		:dword
);
	@cdecl; 
	@external( cPrefix "negval" );
	
	

procedure notval
( 
	var dest	:var;
	var	src		:var;
		vpt		:pType;
	var	vpta	:pType;
		vt		:dword
);
	@cdecl; 
	@external( cPrefix "notval" );
	
	

procedure addval
( 
	var dest	:var;
	var	src		:var;
	var	vpt		:pType;
	var	typ		:var
);
	@cdecl; 
	@external( cPrefix "addval" );
	
	

procedure subval
( 
	var dest	:var;
	var	src		:var;
	var	vpt		:pType;
	var	typ		:var
);
	@cdecl; 
	@external( cPrefix "subval" );
	
	


procedure mulval
( 
	var dest	:var;
	var	src		:var;
	var	vpt		:pType;
	var	typ		:var
);
	@cdecl; 
	@external( cPrefix "mulval" );
	
	


procedure divval
( 
	var dest	:var;
	var	src		:var;
	var	vpt		:pType;
	var	typ		:var
);
	@cdecl; 
	@external( cPrefix "divval" );
	
	


procedure modval
( 
	var dest	:var;
	var	src		:var;
	var	vpt		:pType;
	var	typ		:var
);
	@cdecl; 
	@external( cPrefix "modval" );
	
	


procedure shlval
( 
	var dest	:var;
	var	cnt		:var;
	var	vpt		:pType;
	var	typ		:var
);
	@cdecl; 
	@external( cPrefix "shlval" );
	
	


procedure shrval
( 
	var dest	:var;
	var	cnt		:var;
	var	vpt		:pType;
	var	typ		:var
);
	@cdecl; 
	@external( cPrefix "shrval" );
	
	



procedure InRange
( 
	var	_value	:var; 
		tpt		:pType; 
		vpt		:pType;
	var	vpta	:pType;
	var	vt		:var 
); @cdecl; @external( cPrefix "InRange" );

procedure DecStrToInt
( 
	PtrToStr	:dword;
	PtrToDest	:dword;
	PtrToType	:dword;
	PtrTopType	:dword
);	@cdecl; 
	@external( cPrefix "DecStrToInt" );

procedure BinStrToInt
( 
	PtrToStr	:dword;
	PtrToDest	:dword;
	PtrToType	:dword;
	PtrTopType	:dword
);	@cdecl; 
	@external( cPrefix "BinStrToInt" );

procedure HexStrToInt
( 
	PtrToStr	:dword;
	PtrToDest	:dword;
	PtrToType	:dword;
	PtrTopType	:dword
);	@cdecl; 
	@external( cPrefix "HexStrToInt" );


procedure UnsToStr( var buf:var; var unsval:var );
	@cdecl; 
	@external( cPrefix "UnsToStr" );


procedure IntToStr( var buf:var; var intval:var );
	@cdecl; 
	@external( cPrefix "IntToStr" );



procedure MakeCompAsm
( 
	var	lpType	:pType;
	var	rpType	:pType;
	var	lType	:var;
	var rType	:var;
	var	lData	:var;
	var	rData	:var
);
	@cdecl;
	@external( cPrefix "MakeCompAsm" );
	
	
procedure real80to64( var data:var );
	@cdecl;
	@external( cPrefix "real80to64" );
	
	
procedure real80to32( var data:var );
	@cdecl;
	@external( cPrefix "real80to32" );
	

procedure UnsLT( var left:var; var right:var );
	@cdecl;
	@external( cPrefix "UnsLT" );
	

procedure UnsLE( var left:var; var right:var );
	@cdecl;
	@external( cPrefix "UnsLE" );
	

procedure UnsGT( var left:var; var right:var );
	@cdecl;
	@external( cPrefix "UnsGT" );
	

procedure UnsGE( var left:var; var right:var );
	@cdecl;
	@external( cPrefix "UnsGE" );
	

procedure IntLT( var left:var; var right:var );
	@cdecl;
	@external( cPrefix "IntLT" );
	

procedure IntLE( var left:var; var right:var );
	@cdecl;
	@external( cPrefix "IntLE" );
	

procedure IntGT( var left:var; var right:var );
	@cdecl;
	@external( cPrefix "IntGT" );
	

procedure IntGE( var left:var; var right:var );
	@cdecl;
	@external( cPrefix "IntGE" );
	
procedure bigmaxUns( var dest:var; var left:var; var right:var );
	@cdecl;
	@external( cPrefix "bigmaxUns" );
	
procedure bigmaxInt( var dest:var; var left:var; var right:var );
	@cdecl;
	@external( cPrefix "bigmaxInt" );
	
	
procedure bigminUns( var dest:var; var left:var; var right:var );
	@cdecl;
	@external( cPrefix "bigminUns" );
	
procedure bigminInt( var dest:var; var left:var; var right:var );
	@cdecl;
	@external( cPrefix "bigminInt" );
	

procedure _compactType( var _val:var; var pt:pType; var typ:var );
	@cdecl;
	@external( cPrefix "compactType" );
	
#macro compactType( d, l, r );
	_compactType( d, l, r );
	add( 12, esp );
#endmacro;



// Symbol table support routines:


procedure strcpylc( dest:string; src:string; hash:dword ); 
	@cdecl; 
	@external( cPrefix "strcpylc" );

procedure lowercase( s:string ); @cdecl; @external( cPrefix "lowercase" );

procedure SearchNext
( 
	symptr		:dword; 
	lcName		:dword; 
	length		:dword 
);
	@cdecl; 
	@external( cPrefix "SearchNext" );

procedure SearchHash( symptr:dword; lcName:dword; length:dword );
	@cdecl; 
	@external( cPrefix "SearchHash" );


/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
////////////////                                 ////////////////////////
////////////////  end of external declarations   ////////////////////////
////////////////  Beginning of actual code       ////////////////////////
////////////////  Type Checking Support Routines ////////////////////////
////////////////                                 ////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////


// Symbol table helper functions.
// These routines are all intended to be called from C code and
// assume that they can wipe out the values in EAX, ECX, and EDX.


// lowercase-	funky lower case conversion routine (that's valid
//				only for identifiers that have a-z, A-Z, 0-9, and "_".
//				Note that "_" gets mapped to $7f.  That's okay 'cause
//				it's a unique mapping.

procedure lowercase( s:string ); @nodisplay; @noframe;
begin lowercase;

	mov( [esp+4], edx );	// get ptr to string;
	mov( $20, al );	
	lcLoop:
		inc( edx );
		or( al, [edx-1] );
		cmp( al, [edx-1] );
		jne lcLoop;
		
	mov( 0, (type byte [edx-1]) );
	mov( [esp+4], eax );	// return pointer to string.
	ret();
	
end lowercase;



// SearchHash( symptr, lcName, length )
//
//	symptr points at a linear list of symbols reached by
// indexing a hash table (this is done in the C code).
//
//	lcName is the lowercase'd version of the name (using the
// "lowercase" function above;  note the substitution of
// $7f for "_" (won't affect the comparison at all, since
// the lowercase names in the symbol table have this substitution).

procedure SearchHash( symptr:dword; lcName:dword; length:dword );
	@nodisplay;
	@noframe;

const
	symp	:text := "(type dword [esp+12])";
	lcN		:text := "(type dword [esp+16])";
	len		:text := "(type dword [esp+20])";
	
begin SearchHash;

	push( ebx );
	push( esi );


	// If the pointer to the list is NULL, immediately return.
	
	mov( symp, ebx );
	test( ebx, ebx );
	jz failure;
	
	// The following "while" loop does a linear search through
	// the list of symbol table entries associated with this
	// particular hash table list:
	
	mov( lcN, edx );	// EDX points at the name we're searching for.
	whileLp:

		// First, compare the name lengths.  If they aren't equal,
		// then the identifiers surely aren't equal:
		
		mov( len, ecx );
		cmp( ecx, (type SymNode [ebx]).NameLen );
		jne NextInHashList;
		
		// Okay, the ID lengths agree, now compare the strings.
		// For performance reasons, we'll compare the strings
		// four characters at a time as long as there are at
		// least four characters left in the string.
		
		mov( (type SymNode [ebx]).lcName, esi );
		while( ecx >= 4 ) do
		
			sub( 4, ecx );
			mov( [edx+ecx], eax );
			cmp( eax, [esi+ecx] );
			jne NextInHashList;
			
		endwhile;
		
		// If the string length is not an even multiple of four,
		// we still need to compare the remaining 1, 2, or 3
		// characters of the two strings:
		
		cmp( ecx, 2 );
		jb oneOrZero;
		ja three;
		
			mov( [edx], ax );
			cmp( ax, [esi] );
			jne NextInHashList;
			mov( ebx, eax );
			pop( esi );
			pop( ebx );
			ret();
			
		three:
		
			mov( [edx], ax );
			cmp( ax, [esi] );
			jne NextInHashList;
			mov( [edx+2], al );
			cmp( al, [esi+2] );
			jne NextInHashList;
		success:
			mov( ebx, eax );
			pop( esi );
			pop( ebx );
			ret();
			
		oneOrZero:
			test( ecx, ecx );
			jz success;
		
			mov( [edx], al );
			cmp( al, [esi] );
			jne NextInHashList;
			mov( ebx, eax );
			pop( esi );
			pop( ebx );
			ret();
		
	// Fall down here if the strings we're comparing are not equal.
	// This code moves on to the next symbol table entry in the hash
	// list and repeats the code above if there is another entry.
	
	NextInHashList:
		mov( (type SymNode [ebx]).hashList, ebx );
		test( ebx, ebx );
		jnz whileLp;
		
	// Hit end of list without finding the symbol.
	// return NULL.
		
	failure:
		pop( esi );
		pop( ebx );
		xor( eax, eax );
		ret();
	
end SearchHash;



// SearchNext-	Searches for an identifier through the standard list
//				(off the Next pointer).
//
//	This code is identical to SearchHash above except for a single
// statement near the end (where it finds the next entry in the
// symbol table using the "Next" field rather than the "hashList"
// field).  See the comments in the previous routine for details.

procedure SearchNext
( 
	symptr		:dword; 
	lcName		:dword; 
	length		:dword
);
	@nodisplay;
	@noframe;

const
	symp	:text := "(type dword [esp+12])";
	lcN		:text := "(type dword [esp+16])";
	len		:text := "(type dword [esp+20])";
	glbsyms	:text := "(type dword [esp+24])";
	hsh		:text := "(type dword [esp+28])";
	

readonly
	jmpTbl: dword; @nostorage;
		dword	&NextInList, &ecx1, &ecx2, &ecx3;
		dword	&ecx4, &ecx5, &ecx6, &ecx7;
		dword	&ecx8, &ecx9, &ecx10, &ecx11;
		dword	&ecx12, &ecx13, &ecx14, &ecx15;
		dword	&ecx16, &ecx17, &ecx18, &ecx19;
		dword	&ecx20, &ecx21, &ecx22, &ecx23;
		dword	&ecx24, &ecx25, &ecx26, &ecx27;
		dword	&ecx28;
		
	
begin SearchNext;

	push( ebx );
	push( esi );
	

	mov( symp, ebx );
	test( ebx, ebx );
	jz failure;
	
	mov( lcN, edx );
	whileLp:
	
		mov( len, ecx );
		cmp( ecx, (type SymNode [ebx]).NameLen );
		jne NextInList;

		// Okay, the ID lengths agree, now compare the strings:
		
		mov( (type SymNode [ebx]).lcName, esi );
		cmp( ecx, 28 );
		jae ECXGT28;

		// Note that the length includes the zero byte, we'll ignore
		// that here.

		dec( ecx );
		
		// Special case all the comparisons from one to 20 chars:
		
		jmp( jmpTbl[ecx*4] );
		
		ecx1: 
			mov( [edx], al );
			cmp( al, [esi] );
			jne NextInList;
			mov( ebx, eax );
			pop( esi );
			pop( ebx );
			ret();
			
			
		ecx2:
		
			mov( [edx], ax );
			cmp( ax, [esi] );
			jne NextInList;
			mov( ebx, eax );
			pop( esi );
			pop( ebx );
			ret();
				   		
		ecx3:
		ecx4:
			mov( [edx], eax ); // Compare four bytes is okay for ecx3,
			cmp( eax, [esi] ); // there is a zero terminating byte!
			jne NextInList;
			mov( ebx, eax );
			pop( esi );
			pop( ebx );
			ret();
			
			
		ecx5:
			mov( [edx], eax );
			cmp( eax, [esi] );
			jne NextInList;
			mov( [edx+4], al );
			cmp( al, [esi+4] );
			jne NextInList;
			mov( ebx, eax );
			pop( esi );
			pop( ebx );
			ret();
			
		ecx6:
			mov( [edx], eax );
			cmp( eax, [esi] );
			jne NextInList;
			mov( [edx+4], ax );
			cmp( ax, [esi+4] );
			jne NextInList;
			mov( ebx, eax );
			pop( esi );
			pop( ebx );
			ret();
			
		ecx7:
		ecx8:
			mov( [edx], eax );  
			cmp( eax, [esi] );	
			jne NextInList;
			mov( [edx+4], eax ); // Comparing four bytes for ecx7 is okay
			cmp( eax, [esi+4] ); // because of the zero terminating byte.
			jne NextInList;
			mov( ebx, eax );
			pop( esi );
			pop( ebx );
			ret();
			
		ecx9:
			mov( [edx], eax );  
			cmp( eax, [esi] );	
			jne NextInList;
			mov( [edx+4], eax );
			cmp( eax, [esi+4] );
			jne NextInList;
			mov( [edx+8], al );
			cmp( al, [esi+8] );
			jne NextInList;
			mov( ebx, eax );
			pop( esi );
			pop( ebx );
			ret();
			
		ecx10:
			mov( [edx], eax );
			cmp( eax, [esi] );
			jne NextInList;
			mov( [edx+4], eax );
			cmp( eax, [esi+4] );
			jne NextInList;
			mov( [edx+8], ax );
			cmp( ax, [esi+8] );
			jne NextInList;
			mov( ebx, eax );
			pop( esi );
			pop( ebx );
			ret();
			
		ecx11:
		ecx12:
			mov( [edx], eax );  
			cmp( eax, [esi] );	
			jne NextInList;
			mov( [edx+4], eax );
			cmp( eax, [esi+4] );
			jne NextInList;
			mov( [edx+8], eax );  // Comparing four bytes for ecx11 is okay
			cmp( eax, [esi+8] );  // because of the zero terminating byte.
			jne NextInList;
			mov( ebx, eax );
			pop( esi );
			pop( ebx );
			ret();
			
		ecx13:
			mov( [edx], eax );  
			cmp( eax, [esi] );	
			jne NextInList;
			mov( [edx+4], eax );
			cmp( eax, [esi+4] );
			jne NextInList;
			mov( [edx+8], eax );
			cmp( eax, [esi+8] );
			jne NextInList;
			mov( [edx+12], al );
			cmp( al, [esi+12] );
			jne NextInList;
			mov( ebx, eax );
			pop( esi );
			pop( ebx );
			ret();
			
		ecx14:
			mov( [edx], eax );  
			cmp( eax, [esi] );	
			jne NextInList;
			mov( [edx+4], eax );
			cmp( eax, [esi+4] );
			jne NextInList;
			mov( [edx+8], eax );
			cmp( eax, [esi+8] );
			jne NextInList;
			mov( [edx+12], ax );
			cmp( ax, [esi+12] );
			jne NextInList;
			mov( ebx, eax );
			pop( esi );
			pop( ebx );
			ret();
			
		ecx15:
		ecx16:
			mov( [edx], eax );  
			cmp( eax, [esi] );	
			jne NextInList;
			mov( [edx+4], eax );
			cmp( eax, [esi+4] );
			jne NextInList;
			mov( [edx+8], eax );
			cmp( eax, [esi+8] );
			jne NextInList;
			mov( [edx+12], eax );
			cmp( eax, [esi+12] );
			jne NextInList;
			mov( ebx, eax );
			pop( esi );
			pop( ebx );
			ret();
			
		ecx17:
			mov( [edx], eax );  
			cmp( eax, [esi] );	
			jne NextInList;
			mov( [edx+4], eax );
			cmp( eax, [esi+4] );
			jne NextInList;
			mov( [edx+8], eax );
			cmp( eax, [esi+8] );
			jne NextInList;
			mov( [edx+12], eax );
			cmp( eax, [esi+12] );
			jne NextInList;
			mov( [edx+16], al );
			cmp( al, [esi+16] );
			jne NextInList;
			mov( ebx, eax );
			pop( esi );
			pop( ebx );
			ret();
			
		ecx18:
			mov( [edx], eax );  
			cmp( eax, [esi] );	
			jne NextInList;
			mov( [edx+4], eax );
			cmp( eax, [esi+4] );
			jne NextInList;
			mov( [edx+8], eax );
			cmp( eax, [esi+8] );
			jne NextInList;
			mov( [edx+12], eax );
			cmp( eax, [esi+12] );
			jne NextInList;
			mov( [edx+16], ax );
			cmp( ax, [esi+16] );
			jne NextInList;
			mov( ebx, eax );
			pop( esi );
			pop( ebx );
			ret();
			
		ecx19:
		ecx20:
			mov( [edx], eax );  
			cmp( eax, [esi] );	
			jne NextInList;
			mov( [edx+4], eax );
			cmp( eax, [esi+4] );
			jne NextInList;
			mov( [edx+8], eax );
			cmp( eax, [esi+8] );
			jne NextInList;
			mov( [edx+12], eax );
			cmp( eax, [esi+12] );
			jne NextInList;
			mov( [edx+16], eax );
			cmp( eax, [esi+16] );
			jne NextInList;
			mov( ebx, eax );
			pop( esi );
			pop( ebx );
			ret();
			
		ecx21:
			mov( [edx], eax );  
			cmp( eax, [esi] );	
			jne NextInList;
			mov( [edx+4], eax );
			cmp( eax, [esi+4] );
			jne NextInList;
			mov( [edx+8], eax );
			cmp( eax, [esi+8] );
			jne NextInList;
			mov( [edx+12], eax );
			cmp( eax, [esi+12] );
			jne NextInList;
			mov( [edx+16], eax );
			cmp( eax, [esi+16] );
			jne NextInList;
			mov( [edx+20], al );
			cmp( al, [esi+20] );
			jne NextInList;
			mov( ebx, eax );
			pop( esi );
			pop( ebx );
			ret();
			
		ecx22:
			mov( [edx], eax );  
			cmp( eax, [esi] );	
			jne NextInList;
			mov( [edx+4], eax );
			cmp( eax, [esi+4] );
			jne NextInList;
			mov( [edx+8], eax );
			cmp( eax, [esi+8] );
			jne NextInList;
			mov( [edx+12], eax );
			cmp( eax, [esi+12] );
			jne NextInList;
			mov( [edx+16], eax );
			cmp( eax, [esi+16] );
			jne NextInList;
			mov( [edx+20], ax );
			cmp( ax, [esi+20] );
			jne NextInList;
			mov( ebx, eax );
			pop( esi );
			pop( ebx );
			ret();
			
		ecx23:
		ecx24:
			mov( [edx], eax );  
			cmp( eax, [esi] );	
			jne NextInList;
			mov( [edx+4], eax );
			cmp( eax, [esi+4] );
			jne NextInList;
			mov( [edx+8], eax );
			cmp( eax, [esi+8] );
			jne NextInList;
			mov( [edx+12], eax );
			cmp( eax, [esi+12] );
			jne NextInList;
			mov( [edx+16], eax );
			cmp( eax, [esi+16] );
			jne NextInList;
			mov( [edx+20], eax );
			cmp( eax, [esi+20] );
			jne NextInList;
			mov( ebx, eax );
			pop( esi );
			pop( ebx );
			ret();
			
		ecx25:
			mov( [edx], eax );  
			cmp( eax, [esi] );	
			jne NextInList;
			mov( [edx+4], eax );
			cmp( eax, [esi+4] );
			jne NextInList;
			mov( [edx+8], eax );
			cmp( eax, [esi+8] );
			jne NextInList;
			mov( [edx+12], eax );
			cmp( eax, [esi+12] );
			jne NextInList;
			mov( [edx+16], eax );
			cmp( eax, [esi+16] );
			jne NextInList;
			mov( [edx+20], eax );
			cmp( eax, [esi+20] );
			jne NextInList;
			mov( [edx+24], al );
			cmp( al, [esi+24] );
			jne NextInList;
			mov( ebx, eax );
			pop( esi );
			pop( ebx );
			ret();
			
		ecx26:
			mov( [edx], eax );  
			cmp( eax, [esi] );	
			jne NextInList;
			mov( [edx+4], eax );
			cmp( eax, [esi+4] );
			jne NextInList;
			mov( [edx+8], eax );
			cmp( eax, [esi+8] );
			jne NextInList;
			mov( [edx+12], eax );
			cmp( eax, [esi+12] );
			jne NextInList;
			mov( [edx+16], eax );
			cmp( eax, [esi+16] );
			jne NextInList;
			mov( [edx+20], eax );
			cmp( eax, [esi+20] );
			jne NextInList;
			mov( [edx+24], ax );
			cmp( ax, [esi+24] );
			jne NextInList;
			mov( ebx, eax );
			pop( esi );
			pop( ebx );
			ret();
			
		ecx27:
		ecx28:
			mov( [edx], eax );  
			cmp( eax, [esi] );	
			jne NextInList;
			mov( [edx+4], eax );
			cmp( eax, [esi+4] );
			jne NextInList;
			mov( [edx+8], eax );
			cmp( eax, [esi+8] );
			jne NextInList;
			mov( [edx+12], eax );
			cmp( eax, [esi+12] );
			jne NextInList;
			mov( [edx+16], eax );
			cmp( eax, [esi+16] );
			jne NextInList;
			mov( [edx+20], eax );
			cmp( eax, [esi+20] );
			jne NextInList;
			mov( [edx+24], eax );
			cmp( eax, [esi+24] );
			jne NextInList;
			mov( ebx, eax );
			pop( esi );
			pop( ebx );
			ret();
			
		
			
		
		
		ECXGT28:
		while( ecx >= 4 ) do
		
			sub( 4, ecx );
			mov( [edx+ecx], eax );
			cmp( eax, [esi+ecx] );
			jne NextInList;
			
		endwhile;
		cmp( ecx, 2 );
		jb oneOrZero;
		ja three;
		
			mov( [edx], ax );
			cmp( ax, [esi] );
			jne NextInList;
			mov( ebx, eax );
			pop( esi );
			pop( ebx );
			ret();
			
		three:
			mov( [edx], ax );
			cmp( ax, [esi] );
			jne NextInList;
			mov( [edx+2], al );
			cmp( al, [esi+2] );
			jne NextInList;
		success:
			mov( ebx, eax );
			pop( esi );
			pop( ebx );
			ret();
			
		oneOrZero:
			test( ecx, ecx );
			jz success;
			mov( [edx], al );
			cmp( al, [esi] );
			jne NextInList;
			mov( ebx, eax );
			pop( esi );
			pop( ebx );
			ret();
		
	NextInList:
		cmp( parmLookup, 0 );
		jne CheckEndParms;
		mov( (type SymNode [ebx]).Next, ebx );
		test( ebx, ebx );
		jz failure;
		jmp whileLp;
		
	CheckEndParms:
		cmp( ebx, ProcGlobal );
		je failure;
		mov( (type SymNode [ebx]).Next, ebx );
		test( ebx, ebx );
		jnz whileLp;
		pop( esi );
		pop( ebx );
		xor( eax, eax );
		ret();	
		
	failure:
		pop( esi );
		pop( ebx );
		xor( eax, eax );
		ret();
			
	
end SearchNext;




// strcpylc- copies a string, converts it to lower case while
//			 copying it, and returns the length (zero terminated string).
//			 Also computes the hashing function while doing all this.
//
// Note: this function only gets called when processing identifiers that
// will only have the following chars: a-z, A-Z, 0-9, and "_".  Therefore,
// the lower-case conversion can be kind of cheesy.

procedure strcpylc( dest:string; src:string; hash:dword ); @nodisplay; @noframe;
begin strcpylc;

	mov( [esp+4], edx );	// dest ptr.
	mov( [esp+8], ecx );	// src ptr.
	push( ebx );			// Compute hash function here.
	
	xor( ebx, ebx );
	sub( 1, ecx );
	sub( 1, edx );
	cpyLoop:
		add( 1, ecx );
		add( 1, edx );
		mov( [ecx], al );
		or( $20, al );
		ror( 1, bl );
		mov( al, [edx] );
		xor( al, bl );
		cmp( al, $20 );
		jnz cpyLoop;
			
	mov( 0, (type byte [edx]));	// Zero terminate string.
	mov( edx, eax );			// Compute length of string as
	sub( [esp+8], eax );		// 	end-dest.
	
	mov( [esp+16], edx );	// get ptr to hash variable.
	mov( ebx, [edx] );		// store away hash result.
	
	pop( ebx );
	ret();
	
end strcpylc;
		
   

	


// compactType-
//
//	_val is a integer (signed, unsigned, hexadecimal) value and
// pt/type point at the types fields for this object.  This function
// finds the smallest possible type in the type set (signed, integer
// hexadecimal) for the given value and set the type of the value to
// that minimal type.


procedure _compactType( var _val:var; var pt:pType; var typ:var );
begin _compactType;

	push( eax );
	push( ebx );
	push( edx );
	push( esi );
	
	mov( _val, esi );
	mov( pt, ebx );
	movzx( (type byte [ebx]), edx );

	mov( tUns128, al );
	cmp( dl, tUns128);
	jbe ALtoDl;
	mov( tLWord, al );
	cmp( dl, tLWord );
	jbe ALtoDl;
	mov( tInt128, al );

  ALtoDl:
  	mov( al, dl );
	
	if( dl = tInt128 && (type int8 [esi+15]) < 0 ) then
	
		// Okay, the value is negative, see if the result requires 128 bits:
		
		mov( -1, eax );
		if
		(
				eax = [esi+12]
			&&	eax = [esi+8]
			&&	(type int8 [esi+7]) < 0
		) then
		
			dec( dl );
			if( dl = tTByte ) then
			
				// Skip over TByte, it's handled below.
				
				dec( dl );
				
			endif;
			
			// See if the result requires 64 bits:
			
			if( eax = [esi+4] && (type int8 [esi+3]) < 0 ) then
			
				dec( dl );
				
				// See if the result requires 32 bits:
				
				if( ax = [esi+2] && (type int8 [esi+1]) < 0 ) then
				
					dec( dl );
					
					// See if the result requires 16 bits:
					
					if( al = [esi+1] && (type int8 [esi]) < 0 ) then
					
						dec( dl );
						
					endif;
					
				endif;
				
			endif;
			
		elseif( dl = tLWord ) then 
		
			// Special case for hexadecimal/tbyte values
		
			if
			(
					eax = [esi+12]
				&&	ax = [esi+10]
				&&	(type int8 [esi+9]) < 0
			) then
			
				mov( tTByte, dl );
				
			endif;
			
			
		endif;
			
	else  // The value is positive or zero:
	
		mov( [esi+12], eax );
		or( [esi+8], eax );
		if( @z ) then
		
			if( dl = tLWord ) then
			
				// If hexadecimal, skip tbyte. It's handled below.
				
				dec( dl );
				
			endif;
			dec( dl );
			
			// See if the result requires 64 bits:
			
			if( eax = [esi+4] ) then
			
				dec( dl );
				
				// See if the result requires 32 bits:
				
				if( ax = [esi+2] ) then
				
					dec( dl );
					
					// See if the result requires 16 bits:
					
					if( al = [esi+1] ) then
					
						dec( dl );
						
					endif;
					
				endif;
				
			endif;
			
		elseif( dl = tLWord ) then
		
			movzx( (type word [esi+10]), eax );
			or( [esi+12], eax );
			if( @z ) then
			
				mov( tTByte, dl );
				
			endif;
			
		endif;
	
	
	endif;
	
	// Save away the resulting pType:
	
	mov( dl, [ebx] );
	
	// Get the matching Type:
	
	mov( typeTable[edx*4], eax );
	mov( typ, ebx );
	mov( eax, [ebx] );
	
	pop( esi );
	pop( edx );
	pop( ebx );
	pop( eax );

end _compactType;







// InRange- Checks the value to make sure it is within a specified range.
//
//	Returns:true/false in EAX depending upon whether the value is in range.
//
//	_value-	Pointer to value (up to 128 bits).
//	tpt-	pType that the value must be compatible with.
//	vpt-	_value's pType.
//	vpta-	Pointer to value's symbol table entry for its pType
//	vt-		Pointer to value's symbol table entry for its type.


procedure InRange
( 
	var	_value	:var; 
		tpt		:pType; 
		vpt		:pType;
	var	vpta	:pType; 
	var	vt		:var
);
	@noframe;
	
const
	__value :text := "[esp+12]";
	_tpt	:text := "(type byte [esp+16])";
	_vpt	:text := "(type byte [esp+20])";
	_vpta	:text := "(type dword [esp+24])";
	_vt		:text := "(type dword [esp+28])";
	
static
	tJmpTbl: dword[ uns32(tCset)+1 ] :=
			[ 

				&isBoolean,	
				&isEnum,	
				
				&isUns8,	
				&isUns16,	
				&isUns32,	
				&isUns64,	
				&isUns128,	
				
				&isByte,	
				&isWord,	
				&isDWord,	
				&isQWord,	
				&isTByte,	
				&isLWord,	

				&isInt8,	
				&isInt16,	
				&isInt32,	
				&isInt64,	
				&isInt128,	

				&isChar, 	
				&isWChar,	

				&isReal32,	
				&isReal64, 	
				&isReal80,	
				&Failure,	
				 
				&isString,	
				&isZString,	
				&isWString,	
				&isCset	

			];
			
begin InRange;

	push( ebx );
	push( edx );
	mov( __value, ebx );
	movzx( _vpt, eax );
	movzx( _tpt, edx );
	cmp( dl, tText );
	je isString;
	cmp( dl, tPointer );
	je isPointer;
	cmp( dl, tProcptr );
	je isPointer;
	cmp( dl, tArray );
	jae Failure;
	
	jmp( tJmpTbl[edx*4]);
	

	isBoolean:	
	isEnum:	
	isCset:	
	isWString:	

	Failure:
		xor( eax, eax );
		pop( edx );
		pop( ebx );
		ret();
		
		


	// The destination type is Uns8, make sure we've got an integer
	// value and it's within a reasonable range.
	// The following code depends upon unsXX < hexXX < intXX.
	
	isUns8:	
		cmp( al, tUns8 );
		jb Failure;
		cmp( al, tLWord );
		jbe doUns8Uns;
		cmp( al, tInt128 );
		ja Failure;
		
		// Okay, it's int8..int128 here.  Make sure the
		// value is in the range 0..+127:
	
		mov( [ebx], eax );
		cmp( eax, 127 );
		ja Failure;
		mov( [ebx+4], eax );
		or( [ebx+8], eax );
		or( [ebx+12], eax );
		jne Failure;
		
		// Set the value's type to uns8:
		
	setUns8:		
		mov( _vpta, ebx );
		mov( tUns8, (type pType [ebx]));
		mov( _vt, ebx );
		mov( &uns8_ste, (type dword [ebx]));
		
		mov( 1, eax );
		pop( edx );
		pop( ebx );
		ret();
		
		
	doUns8Uns:
	
		// It's uns8..uns128 here, make sure it's in the range
		// 0..255:
		
		mov( [ebx], eax );
		cmp( eax, 255 );
		ja Failure;
		mov( [ebx+4], eax );
		or( [ebx+8], eax );
		or( [ebx+12], eax );
		je setUns8;
		xor( eax, eax );
		pop( edx );
		pop( ebx );
		ret();
		
		


	// The destination type is Uns16, make sure we've got an integer
	// value and it's within a reasonable range.
	// The following code depends upon unsXX < hexXX < intXX.
	
	isUns16:	
		cmp( al, tUns8 );
		jb Failure;
		cmp( al, tLWord );
		jbe doUns16Uns;
		cmp( al, tInt128 );
		ja Failure;
		
		// Okay, it's int8..int128 here.  Make sure the
		// value is in the range 0..+32767:
	
		mov( [ebx], eax );
		cmp( eax, 32767 );
		ja Failure;
		mov( [ebx+4], eax );
		or( [ebx+8], eax );
		or( [ebx+12], eax );
		jne Failure;

		// Set the value's type to uns16:
		
	setUns16:		
		mov( _vpta, ebx );
		mov( tUns16, (type pType [ebx]));
		mov( _vt, ebx );
		mov( &uns16_ste, (type dword [ebx]));
		mov( 1, eax );
		pop( edx );
		pop( ebx );
		ret();
		
		
	doUns16Uns:
	
		// It's uns8..LWord here, make sure it's in the range
		// 0..65535:
		
		movzx( (type word [ebx+2]), eax );
		or( [ebx+4], eax );
		or( [ebx+8], eax );
		or( [ebx+12], eax );
		je setUns16;
		xor( eax, eax );
		pop( edx );
		pop( ebx );
		ret();
		
		


	// The destination type is Uns32, make sure we've got an integer
	// value and it's within a reasonable range.
	// The following code depends upon unsXX < hexXX < intXX.
	
	isUns32:	
		cmp( al, tUns8 );
		jb Failure;
		cmp( al, tLWord );
		jbe doUns32Uns;
		cmp( al, tInt128 );
		ja Failure;
		
		// Okay, it's int8..int128 here.  Make sure the
		// value is in the range 0..$7FFF_FFFF:
	
		mov( [ebx], eax );
		cmp( eax, $7FFF_FFFF );
		ja Failure;
		mov( [ebx+4], eax );
		or( [ebx+8], eax );
		or( [ebx+12], eax );
		jne Failure;

		// Set the value's type to uns32:
		
	setUns32:		
		mov( _vpta, ebx );
		mov( tUns32, (type pType [ebx]));
		mov( _vt, ebx );
		mov( &uns32_ste, (type dword [ebx]));
		mov( 1, eax );
		pop( edx );
		pop( ebx );
		ret();
		
		
	doUns32Uns:
	
		// It's uns8..LWord here, make sure it's in the range
		// 0..$FFFF_FFFF:
		
		mov( [ebx+4], eax );
		or( [ebx+8], eax );
		or( [ebx+12], eax );
		je setUns32;
		xor( eax, eax );
		pop( edx );
		pop( ebx );
		ret();
		
		


	// The destination type is Uns64, make sure we've got an integer
	// value and it's within a reasonable range.
	// The following code depends upon unsXX < hexXX < intXX.
	
	isUns64:	
		cmp( al, tUns8 );
		jb Failure;
		cmp( al, tLWord );
		jbe doUns64Uns;
		cmp( al, tInt128 );
		ja Failure;
		
		// Okay, it's int8..int128 here.  Make sure the
		// value is in the range 0..$7FFF_FFFF_FFFF_FFFF:
	
		mov( [ebx+4], eax );
		cmp( eax, $7FFF_FFFF );
		ja Failure;
		mov( [ebx+8], eax );
		or( [ebx+12], eax );
		jne Failure;

		// Set the value's type to uns64:
		
	setUns64:		
		mov( _vpta, ebx );
		mov( tUns64, (type pType [ebx]));
		mov( _vt, ebx );
		mov( &uns64_ste, (type dword [ebx]));
		mov( 1, eax );
		pop( edx );
		pop( ebx );
		ret();
		
		
	doUns64Uns:
	
		// It's uns8..LWord here, make sure it's in the range
		// 0..$FFFF_FFFF:
		
		mov( [ebx+8], eax );
		or( [ebx+12], eax );
		je setUns64;
		xor( eax, eax );
		pop( edx );
		pop( ebx );
		ret();
		
		


	// The destination type is Uns128, About the only thing
	// it won't accept is a negative number.
	// The following code depends upon unsXX < hexXX < intXX.
	
	isUns128:
		cmp( al, tUns8 );
		jb Failure;
		cmp( al, tLWord );
		jbe setUns128;
		cmp( al, tInt128 );
		ja Failure;
		cmp( (type byte [ebx+15]), 0 );
		jl Failure;

	// Set the value's type to uns128:
		
	setUns128:		
		mov( _vpta, ebx );
		mov( tUns128, (type pType [ebx]));
		mov( _vt, ebx );
		mov( &uns128_ste, (type dword [ebx]));
		mov( 1, eax );
		pop( edx );
		pop( ebx );
		ret();
		
		

	// Bytes accept any ordinal value in the range -128..255:
	
	isByte:
		cmp( al, tWChar );
		ja Failure;
		movzx( (type byte [ebx+1]), eax );
		or( [ebx+2], ax );
		or( [ebx+4], eax );
		or( [ebx+8], eax );
		or( [ebx+12], eax );
		je setByte;
		movsx( (type byte [ebx]), eax );
		mov( ah, al );
		and( [ebx+1], al );
		and( [ebx+2], ax );
		and( [ebx+4], eax );
		and( [ebx+8], eax );
		and( [ebx+12], eax );
		cmp( eax, $FFFF_FFFF );
		jne Failure;

	// Set the value's type to Byte:
		
	setByte:		
		mov( _vpta, ebx );
		mov( _tByte, (type pType [ebx]));
		mov( _vt, ebx );
		mov( &byte_ste, (type dword [ebx]));
		mov( 1, eax );
		pop( edx );
		pop( ebx );
		ret();
		
	// Words accept any ordinal value in the range -32768..$FFFF:
	
	isWord:	
		cmp( al, tWChar );
		ja Failure;
		movzx( (type word [ebx+2]), eax );
		or( [ebx+4], eax );
		or( [ebx+8], eax );
		or( [ebx+12], eax );
		je setWord;
		movsx( (type byte [ebx+1]), eax );
		mov( ah, al );
		and( [ebx+2], ax );
		and( [ebx+4], eax );
		and( [ebx+8], eax );
		and( [ebx+12], eax );
		cmp( eax, $FFFF_FFFF );
		jne Failure;

	// Set the value's type to Word:
		
	setWord:		
		mov( _vpta, ebx );
		mov( tWord, (type pType [ebx]));
		mov( _vt, ebx );
		mov( &word_ste, (type dword [ebx]));
		mov( 1, eax );
		pop( edx );
		pop( ebx );
		ret();
		
	// DWords accept any ordinal value in the range $00..$FFFF_FFFF.
	// They're also compatible with pointer types.
	
	isDWord:	
		cmp( al, tWChar );
		ja checkPtrDW;
		mov( [ebx+4], eax );
		or( [ebx+8], eax );
		or( [ebx+12], eax );
		je setDWord;

		movsx( (type byte [ebx+3]), eax );
		mov( ah, al );
		and( [ebx+4], eax );
		and( [ebx+8], eax );
		and( [ebx+12], eax );
		cmp( eax, $FFFF_FFFF );
		jne Failure;
		

		// Set the value's type to DWord:
		
	setDWord:		
		mov( _vpta, ebx );
		mov( tDWord, (type pType [ebx]));
		mov( _vt, ebx );
		mov( &dword_ste, (type dword [ebx]));
		mov( 1, eax );
		pop( edx );
		pop( ebx );
		ret();
		
		
	checkPtrDW:
		cmp( al, tPointer );
		je Success;
		cmp( al, tProcptr );
		je Success;
		xor( eax, eax );
		pop( edx );
		pop( ebx );
		ret();
		
		
	// QWords accept any ordinal value in the range $00..$FFFF_FFFF_FFFF_FFFF:
	
	isQWord:	
		cmp( al, tWChar );
		ja Failure;

		// If the H.O. bytes are all zero (bits 64..127)
		// then it can be a qword.
		
		mov( (type dword [ebx+8]), eax );
		or( (type dword [ebx+12]), eax );
		je setQWord;

		// If the value is sign extended through bit 127,
		// then it can be a qword:
		
		movsx( (type byte [ebx+7]), eax );
		mov( ah, al );
		cmp( eax, [ebx+8] );
		jne Failure;
		cmp( eax, [ebx+12] );
		jne Failure;
		

		// Set the value's type to QWord:
		
	setQWord:		
		mov( _vpta, ebx );
		mov( tQWord, (type pType [ebx]));
		mov( _vt, ebx );
		mov( &qword_ste, (type dword [ebx]));
		mov( 1, eax );
		pop( edx );
		pop( ebx );
		ret();
		
		
	// TBytes accept any ordinal value in the range 
	// $00..$FFFF_FFFF_FFFF_FFFF_FFFF:
	
	isTByte:	
		cmp( al, tWChar );
		ja Failure;

		// If the H.O. bytes are all zero (bits 80..127)
		// then it can be a tbyte.
		
		movzx( (type word [ebx+10]), eax );
		or( (type dword [ebx+12]), eax );
		je setTByte;

		// If the value is sign extended through bit 127,
		// then it can be a tbyte:
		
		movsx( (type byte [ebx+9]), eax );
		mov( ah, al );
		cmp( ax, [ebx+10] );
		jne Failure;
		cmp( eax, [ebx+12] );
		jne Failure;
		

		// Set the value's type to TByte:
		
	setTByte:		
		mov( _vpta, ebx );
		mov( tTByte, (type pType [ebx]));
		mov( _vt, ebx );
		mov( &tbyte_ste, (type dword [ebx]));
		mov( 1, eax );
		pop( edx );
		pop( ebx );
		ret();
		
	// LWords accept any ordinal value:
	
	isLWord:	
		cmp( al, tWChar );
		ja Failure;
		
		mov( _vpta, ebx );
		mov( tLWord, (type pType [ebx]));
		mov( _vt, ebx );
		mov( &lword_ste, (type dword [ebx]));
		
		mov( 1, eax );
		pop( edx );
		pop( ebx );
		ret();
		

	// The destination type is Int8, make sure we've got an integer
	// value and it's within a reasonable range.
	// The following code depends upon unsXX < hexXX < intXX.
	
	isInt8:	
		cmp( al, tUns8 );
		jb Failure;
		cmp( al, tUns128 );
		jbe doInt8Uns;
		cmp( al, tLWord );
		jbe doInt8Hex;
		cmp( al, tInt128 );
		ja Failure;
		
		// Okay, it's int8..int128 here.  Make sure the
		// value is in the range -128..+127:
		
		mov( [ebx], eax );
		cdq();
		cmp( eax, -128);
		jl Failure;
		cmp( eax, 127 );
		jg Failure;
		cmp( edx, [ebx+4] );
		jne Failure;
		cmp( edx, [ebx+8] );
		jne Failure;
		cmp( edx, [ebx+12] );
		jne Failure;
		
		
	setInt8:

		// To be on the safe side, sign extend the value to 128 bits:
		
		movsx( (type byte [ebx]), eax );
		mov( eax, [ebx] );
		mov( ah, al );
		mov( eax, [ebx+4] );
		mov( eax, [ebx+8] );
		mov( eax, [ebx+12] );

		mov( _vpta, ebx );
		mov( tInt8, (type pType [ebx]));
		mov( _vt, ebx );
		mov( &int8_ste, (type dword [ebx]));
		
		mov( 1, eax );
		pop( edx );
		pop( ebx );
		ret();
		
	doInt8Hex:
	
		// It's a byte..LWord value.  Verify that it's
		// in the range $0..$FF or the H.O.
		// 15 bytes are all $FF and bit #7 is set.
		
		movzx( (type byte [ebx+1]), eax );
		or( [ebx+2], ax );
		or( [ebx+4], eax );
		or( [ebx+8], eax );
		or( [ebx+12], eax );
		jz setInt8;
		mov( [ebx], eax );
		mov( ah, al );
		and( [ebx+4], eax );
		and( [ebx+8], eax );
		and( [ebx+12], eax );
		cmp( eax, $FFFF_FFFF );
		je setInt8;
		xor( eax, eax );
		pop( edx );
		pop( ebx );
		ret();
	
		
	doInt8Uns:
	
		// It's uns8..uns128 here, make sure it's in the range
		// 0..127:
		
		mov( [ebx], eax );
		cmp( eax, 127 );
		ja FailureI8U;
		mov( [ebx+4], eax );
		or( [ebx+8], eax );
		or( [ebx+12], eax );
		je setInt8;
	
	FailureI8U:
		xor( eax, eax );
		pop( edx );
		pop( ebx );
		ret();
		
		
		
		
	// The destination type is Int16, make sure we've got an integer
	// value and it's within a reasonable range.
	// The following code depends upon unsXX < hexXX < intXX.
	
	isInt16:	
		cmp( al, tUns8 );
		jb int16Failure;
		cmp( al, tUns128 );
		jbe doInt16Uns;
		cmp( al, tLWord );
		jbe doInt16Hex;
		cmp( al, tInt128 );
		ja int16Failure;
		
		// Okay, it's int8..int128 here.  Make sure the
		// value is in the range -32768..+32767:
		
		mov( [ebx], eax );
		cdq();
		cmp( eax, -32768);
		jl int16Failure;
		cmp( eax, 32768 );
		jg int16Failure;
		cmp( edx, [ebx+4] );
		jne int16Failure;
		cmp( edx, [ebx+8] );
		jne int16Failure;
		cmp( edx, [ebx+12] );
		jne int16Failure;
		
	setInt16:
	
		// To be on the safe side, sign extend the value to 128 bits:
		
		movsx( (type byte [ebx+1]), eax );
		mov( ah, al );
		mov( ax, [ebx+2] );
		mov( eax, [ebx+4] );
		mov( eax, [ebx+8] );
		mov( eax, [ebx+12] );
	
		mov( _vpta, ebx );
		mov( tInt16, (type pType [ebx]));
		mov( _vt, ebx );
		mov( &int16_ste, (type dword [ebx]));
		
		mov( 1, eax );
		pop( edx );
		pop( ebx );
		ret();
		
	
	doInt16Hex:
	
		// It's a byte..LWord value.  Verify that it's
		// in the range $0..$FFFF or the H.O.
		// 14 bytes are all $FF and bit #15 is set.
		
		movzx( (type word [ebx+2]), eax );
		or( [ebx+4], eax );
		or( [ebx+8], eax );
		or( [ebx+12], eax );
		jz setInt16;
		movsx( (type byte [ebx+1]), eax );
		mov( ah, al );
		and( [ebx+2], ax );
		and( [ebx+4], eax );
		and( [ebx+8], eax );
		and( [ebx+12], eax );
		cmp( eax, $FFFF_FFFF );
		je setInt16;
		xor( eax, eax );
		pop( edx );
		pop( ebx );
		ret();
		
		
		
		
	doInt16Uns:
	
		// It's uns8..uns128 here, make sure it's in the range
		// 0..32767:
		
		mov( [ebx], eax );
		cmp( eax, 32767 );
		ja int16Failure;
		mov( [ebx+4], eax );
		or( [ebx+8], eax );
		or( [ebx+12], eax );
		je setInt16;
		
	int16Failure:
		xor( eax, eax );
		pop( edx );
		pop( ebx );
		ret();
		
		
		
		
	// The destination type is Int32, make sure we've got an integer
	// value and it's within a reasonable range.
	// The following code depends upon unsXX < hexXX < intXX.
	
	isInt32:	
		cmp( al, tUns8 );
		jb int32Failure;
		cmp( al, tUns128 );
		jbe doInt32Uns;
		cmp( al, tLWord );
		jbe	doInt32Hex;
		cmp( al, tInt128 );
		ja int32Failure;
		
		
		// Okay, it's int8..int128 here.  Make sure the
		// value is in the range -2billion..+2billion:
						 
		mov( [ebx], eax );
		cdq();
		cmp( edx, [ebx+4] );
		jne int32Failure;
		cmp( edx, [ebx+8] );
		jne int32Failure;
		cmp( edx, [ebx+12] );
		jne int32Failure;
		
	setInt32:
	
		// To be on the safe side, sign extend the value to 128 bits:
		
		movsx( (type byte [ebx+3]), eax );
		mov( ah, al );
		mov( eax, [ebx+4] );
		mov( eax, [ebx+8] );
		mov( eax, [ebx+12] );

		mov( _vpta, ebx );
		mov( tInt32, (type pType [ebx]));
		mov( _vt, ebx );
		mov( &int32_ste, (type dword [ebx]));
		
		mov( 1, eax );
		pop( edx );
		pop( ebx );
		ret();
		
	
	doInt32Hex:
	
		// It's a byte..LWord value.  Verify that it's
		// in the range $0..$FFFF_FFFF or the H.O.
		// 12 bytes are all $FF and bit #31 is set.
		
		mov( [ebx+4], eax );
		or( [ebx+8], eax );
		or( [ebx+12], eax );
		jz setInt32;
		movsx( (type byte [ebx+3]), eax );
		mov( ah, al );
		and( [ebx+4], eax );
		and( [ebx+8], eax );
		and( [ebx+12], eax );
		cmp( eax, $FFFF_FFFF );
		je setInt32;
		xor( eax, eax );
		pop( edx );
		pop( ebx );
		ret();
		
		
		
	doInt32Uns:
	
		// It's uns8..uns128 here, make sure it's in the range
		// 0..$7FFF_FFFF:
		
		mov( [ebx], eax );
		cmp( eax, $7FFF_FFFF );
		ja int32Failure;
		mov( [ebx+4], eax );
		or( [ebx+8], eax );
		or( [ebx+12], eax );
		je setInt32;
	
	int32Failure:
		xor( eax, eax );
		pop( edx );
		pop( ebx );
		ret();
		
		
		
		
	// The destination type is Int64, make sure we've got an integer
	// value and it's within a reasonable range.
	// The following code depends upon unsXX < hexXX < intXX.
	
	isInt64:	
		cmp( al, tUns8 );
		jb int64Failure;
		cmp( al, tUns128 );
		jbe doInt64Uns;
		cmp( al, tLWord );
		jbe doInt64Hex;
		cmp( al, tInt128 );
		ja int64Failure;
		
		// Okay, it's byte..int128 here.  Make sure the
		// value is in the proper range:
		
		mov( [ebx], eax );
		cdq();
		cmp( edx, [ebx+8] );
		jne int64Failure;
		cmp( edx, [ebx+12] );
		jne int64Failure;
		
	setInt64:
	
		// To be on the safe side, sign extend the value to 128 bits:
		
		movsx( (type byte [ebx+7]), eax );
		mov( ah, al );
		mov( eax, [ebx+8] );
		mov( eax, [ebx+12] );

		mov( _vpta, ebx );
		mov( tInt64, (type pType [ebx]));
		mov( _vt, ebx );
		mov( &int64_ste, (type dword [ebx]));
		
		mov( 1, eax );
		pop( edx );
		pop( ebx );
		ret();
		
	
	doInt64Hex:
	
		// It's a byte..LWord value.  Verify that it's
		// in the range $0..$FFFF_FFFF_FFFF_FFFF or the H.O.
		// 8 bytes are all $FF and bit #63 is set.
		
		mov( [ebx+8], eax );
		or( [ebx+12], eax );
		jz setInt64;
		movsx( (type byte [ebx+7]), eax );
		mov( ah, al );
		and( [ebx+8], eax );
		and( [ebx+12], eax );
		cmp( eax, $FFFF_FFFF );
		je setInt64;
		xor( eax, eax );
		pop( edx );
		pop( ebx );
		ret();
		
	doInt64Uns:
	
		// It's uns8..uns128 here, make sure it's in the proper range:
		
		mov( [ebx+4], eax );
		cmp( eax, $7FFF_FFFF );
		ja int64Failure;
		mov( [ebx+8], eax );
		or( [ebx+12], eax );
		je setInt64;
		
	int64Failure:
		xor( eax, eax );
		pop( edx );
		pop( ebx );
		ret();
		
		
		
		
	// The destination type is Int128, make sure we've got an integer
	// value and it's within a reasonable range.
	// Note that about the only thing that is unreasonable is
	// an uns128 value >= $8000_0000_0000_0000
	
	isInt128:	
		cmp( al, tUns8 );
		jb int128Failure;
		cmp( al, tUns128 );
		jb setInt128;
		je TryInt128Uns;
		cmp( al, tInt128 );
		ja int128Failure;
		
		
	setInt128:
		mov( _vpta, ebx );
		mov( tInt128, (type pType [ebx]));
		mov( _vt, ebx );
		mov( &int128_ste, (type dword [ebx]));
		mov( 1, eax );
		pop( edx );
		pop( ebx );
		ret();
		
	TryInt128Uns:
		cmp( (type byte [ebx+15]), $80 );
		jb setInt128;
	int128Failure:
		xor( eax, eax );
		pop( edx );
		pop( ebx );
		ret();
		
		
		
		
	/////////// Handle Real32 dest types here ////////////
		
	isReal32:	
		cmp( al, tUns8 );
		jb int128Failure;
		cmp( al, tLWord );
		jbe IsReal32Uns;
		
		cmp( al, tInt128 );
		jbe IsReal32Int;
		
		cmp( al, tReal32 );
		jb int128Failure;
		je real32Success;
		cmp( al, tReal64 );
		je IsReal3264;
		cmp( al, tReal80 );
		jne int128Failure; 
		
		// Need to force the REAL80 constant to REAL32:
		
		fld( (type real80 [ebx]) );
		fstp( (type real32 [ebx]) );
		mov( 0, (type dword [ebx+4]));
		mov( 0, (type dword [ebx+8]));
		mov( 0, (type dword [ebx+12]));
		mov( _vpta, ebx );
		mov( tReal32, (type pType [ebx]));
		mov( _vt, ebx );
		mov( &real32_ste, (type dword [ebx]));
		
	real32Success:
		mov( 1, eax );
		pop( edx );
		pop( ebx );
		ret();
		
		// Need to force the REAL64 constant to REAL32:
		
	IsReal3264:
		fld( (type real64 [ebx]) );
		fstp( (type real32 [ebx]) );
		mov( 0, (type dword [ebx+4]) );
		mov( 0, (type dword [ebx+8]) );
		mov( 0, (type dword [ebx+12]) );

		mov( _vpta, ebx );
		mov( tReal32, (type pType [ebx]));
		mov( _vt, ebx );
		mov( &real32_ste, (type dword [ebx]));
		mov( 1, eax );
		pop( edx );
		pop( ebx );
		ret();
		
	
	IsReal32Uns:
		
		// We have to verify that the number has no more than
		// 23 bits to convert to real32:
		
		mov( [ebx+4], eax );
		or( [ebx+8], eax );
		or( [ebx+12], eax );
		jnz Failure;
		mov( [ebx], eax );
		and( $FF80_0000, eax );
		jnz Failure;
		
		fild( (type dword [ebx]) );
		fstp( (type real32 [ebx]) );
		mov( 0, (type dword [ebx+4]) );
		mov( 0, (type dword [ebx+8]) );
		mov( 0, (type dword [ebx+12]) );
		mov( _vpta, ebx );
		mov( tReal32, (type pType [ebx]));
		mov( _vt, ebx );
		mov( &real32_ste, (type dword [ebx]));
		mov( 1, eax );
		pop( edx );
		pop( ebx );
		ret();
		
		
		
	
	IsReal32Int:
		
		// We have to verify that the number has no more than
		// 23 bits to convert to real32:
		
		movsx( (type byte [ebx+2]), eax );
		mov( ah, al );
		cmp( eax, [ebx+4] );
		jne Failure;
		cmp( eax, [ebx+8] );
		jne Failure;
		cmp( eax, [ebx+12] );
		jne Failure;
				
		fild( (type dword [ebx]) );
		fstp( (type real32 [ebx]) );
		mov( 0, (type dword [ebx+4]) );
		mov( 0, (type dword [ebx+8]) );
		mov( 0, (type dword [ebx+12]) );
		mov( _vpta, ebx );
		mov( tReal32, (type pType [ebx]));
		mov( _vt, ebx );
		mov( &real32_ste, (type dword [ebx]));
		mov( 1, eax );
		pop( edx );
		pop( ebx );
		ret();
		
		
	/////////// Handle Real64 dest types here ////////////
		
	 
	isReal64: 	
		cmp( al, tUns8 );
		jb Failure;
		cmp( al, tLWord );
		jbe IsReal64Uns;
		
		cmp( al, tInt128 );
		jbe IsReal64Int;
		
		cmp( al, tReal32 );
		je IsReal6432;
		cmp( al, tReal64 );
		je Success;
		cmp( al, tReal80 );
		jne Failure;
		
		// We have to change the value as well as the type!
		
		fld( (type real80 [ebx]) );
		fstp( (type real64 [ebx]) );
		mov( 0, (type dword [ebx+8]) );
		mov( 0, (type dword [ebx+12]) );

		mov( _vpta, ebx );
		mov( tReal64, (type pType [ebx]));
		mov( _vt, ebx );
		mov( &real64_ste, (type dword [ebx]));
		
		mov( 1, eax );
		pop( edx );
		pop( ebx );
		ret();
		
	IsReal6432:
	
		fld( (type real32 [ebx]) );
		fstp( (type real64 [ebx]) );
		mov( 0, (type dword [ebx+8]) );
		mov( 0, (type dword [ebx+12]) );

		mov( _vpta, ebx );
		mov( tReal64, (type pType [ebx]));
		mov( _vt, ebx );
		mov( &real64_ste, (type dword [ebx]));
		
		mov( 1, eax );
		pop( edx );
		pop( ebx );
		ret();



	IsReal64Uns:
		
		// We have to verify that the number has no more than
		// 52 bits to convert to real64:
		
		mov( [ebx+8], eax );
		or( [ebx+12], eax );
		jnz Failure;
		mov( [ebx+4], eax );
		and( $FFF0_0000, eax );
		jnz Failure;
		
		fild( (type qword [ebx]) );
		fstp( (type real64 [ebx]) );
		mov( 0, (type dword [ebx+8]) );
		mov( 0, (type dword [ebx+12]) );
		mov( _vpta, ebx );
		mov( tReal64, (type pType [ebx]));
		mov( _vt, ebx );
		mov( &real64_ste, (type dword [ebx]));
		mov( 1, eax );
		pop( edx );
		pop( ebx );
		ret();
		
		
		
		
		
	
	IsReal64Int:
		
		// We have to verify that the number has no more than
		// 52 bits to convert to real64:
		
		mov( [ebx+6], al );
		shl( 4, al );
		movsx( al, eax );
		mov( ah, al );
		cmp( eax, [ebx+4] );
		jne Failure;
		cmp( eax, [ebx+8] );
		jne Failure;
		cmp( eax, [ebx+12] );
		jne Failure;
				
		fild( (type qword [ebx]) );
		fstp( (type real64 [ebx]) );
		mov( 0, (type dword [ebx+8]) );
		mov( 0, (type dword [ebx+12]) );
		mov( _vpta, ebx );
		mov( tReal64, (type pType [ebx]));
		mov( _vt, ebx );
		mov( &real64_ste, (type dword [ebx]));
		mov( 1, eax );
		pop( edx );
		pop( ebx );
		ret();

		
	
	/////////// Handle Real80 dest types here ////////////
		
	 
	isReal80:	
		cmp( al, tUns8 );
		jb Failure;
		cmp( al, tLWord );
		jbe IsReal80Uns;
		
		cmp( al, tInt128 );
		jbe IsReal80Int;
		
		cmp( al, tReal32 );
		je IsReal8032;
		
		cmp( al, tReal80 );
		je Success;
		
		cmp( al, tReal64 );
		jne Failure;
		
		// We have to change the value as well as the type!
		
		fld( (type real64 [ebx]) );
		fstp( (type real80 [ebx]) );
		mov( 0, (type word [ebx+10]));
		mov( 0, (type dword [ebx+12]));

		mov( _vpta, ebx );
		mov( tReal80, (type pType [ebx]));
		mov( _vt, ebx );
		mov( &real80_ste, (type dword [ebx]));
		
		mov( 1, eax );
		pop( edx );
		pop( ebx );
		ret();
		
	IsReal8032:		
		fld( (type real32 [ebx]) );
		fstp( (type real80 [ebx]) );
		mov( 0, (type word [ebx+10]));
		mov( 0, (type dword [ebx+12]));

		mov( _vpta, ebx );
		mov( tReal80, (type pType [ebx]));
		mov( _vt, ebx );
		mov( &real80_ste, (type dword [ebx]));
		
		mov( 1, eax );
		pop( edx );
		pop( ebx );
		ret();
		
	IsReal80Uns:
		
		// We have to verify that the number has no more than
		// 63 bits to convert to real80:
		
		mov( [ebx+7], al );
		and( $80, eax );
		or( (type dword [ebx+8]), eax );
		or( (type dword [ebx+12]), eax );
		jnz Failure;
		
		fild( (type qword [ebx]) );
		fstp( (type real80 [ebx]) );
		mov( 0, (type word [ebx+10]) );
		mov( 0, (type dword [ebx+12]) );
		mov( _vpta, ebx );
		mov( tReal80, (type pType [ebx]));
		mov( _vt, ebx );
		mov( &real80_ste, (type dword [ebx]));
		mov( 1, eax );
		pop( edx );
		pop( ebx );
		ret();
		
	IsReal80Int:
		
		// We have to verify that the number has no more than
		// 64 bits to convert to real80:
		
		movsx( (type byte [ebx+7]), eax );
		mov( ah, al );
		cmp( eax, [ebx+8] );
		jne Failure;
		cmp( eax, [ebx+12] );
		jne Failure;
		
		fild( (type qword [ebx]) );
		fstp( (type real80 [ebx]) );
		mov( 0, (type word [ebx+10]) );
		mov( 0, (type dword [ebx+12]) );
		mov( _vpta, ebx );
		mov( tReal80, (type pType [ebx]));
		mov( _vt, ebx );
		mov( &real80_ste, (type dword [ebx]));
		mov( 1, eax );
		pop( edx );
		pop( ebx );
		ret();
		
	 
	// Strings allow compatibility with characters (text is thrown in
	// here for fun, but this code never sees text objects since the
	// lexer expands them automatically).
	//
	// Note: Someday I should add support for wstring strings here.
	
	isZString:
	isString:
	isText:	
		cmp( al, tString );
		je Success;
		cmp( al, tPointer );
		je Success;
		cmp( al, tChar );
		jne Failure;
		
		malloc2( 4 );
	
		mov( [ebx], dl );		//Get the character.
		mov( dl, [eax] );		// and convert it to a string.
		mov( 0, (type byte [eax+1]) );
		mov( eax, [ebx] );		// Save away pointer to string.
		
		// We need the change the type to string:
		
		mov( _vpta, ebx );
		mov( tString, (type pType [ebx]));
		mov( _vt, ebx );
		mov( &string_ste, (type dword [ebx]));
			
		
		mov( 1, eax );
		pop( edx );
		pop( ebx );
		ret();
		
		
	// Characters and WChars are reasonbly compatible.
	
	isChar:
		cmp( al, tChar );
		je Success;
		cmp( al, tWChar );
		jne Failure;
		
		// If we've got a UNICODE character, it's compatible with
		// char as long as the H.O. byte is zero.
		
		cmp( (type byte [ebx+1]), 0 );
		jne Failure;
		
		//  Okay, it's a good character value.  Let's change the
		// type of the value:
		
		mov( _vpta, ebx );
		mov( tChar, (type pType [ebx]));
		mov( _vt, ebx );
		mov( &char_ste, (type dword [ebx]));
		mov( 1, eax );
		pop( edx );
		pop( ebx );
		ret();
	
	isWChar:	
		cmp( al, tWChar );
		je Success;
		cmp( al, tChar );
		jne Failure;
		
		// If we've got a regular character, convert it to unicode.
				
		mov( 0, (type byte [ebx]));
		mov( _vpta, ebx );
		mov( tWChar, (type pType [ebx]));
		mov( _vt, ebx );
		mov( &wchar_ste, (type dword [ebx]));
	
	Success:
		mov( 1, eax );
		pop( edx );
		pop( ebx );
		ret();
	

		

	// Pointers and procedure pointers allow arbitrary pointer
	// or procptr types.
	
	isProcptr:	
	isPointer:
		cmp( al, tPointer );
		je Success;
		cmp( al, tProcptr );
		je Success;
		cmp( al, tDWord );
		je Success;
		xor( eax, eax );
		pop( edx );
		pop( ebx );
		ret();

end InRange;





/****************************************************************/
/*                                                              */
/* MakeCompAsm -                                                */
/*                                                              */
/* Given two operands (a left and right operand), this function */
/* adjusts the type and ptypes of the two operands to make      */
/* them compatible (including a conversion, if necessary).      */
/* This code uses a two-dimensional jump table to do the        */
/* job (indexed by the left and right operand's pTypes).        */
/*                                                              */
/****************************************************************/

procedure MakeCompAsm
( 
	var	lpType	:pType;
	var	rpType	:pType;
	var	lType	:var;
	var rType	:var;
	var	lData	:var;
	var	rData	:var
);

const
	lpt :text := "(type byte [ebx])";
	rpt :text := "(type byte [ecx])";
	lt  :text := "(type dword [edi])";
	rt  :text := "(type dword [esi])";

static
	jmpTbl	:dword[ uns32(tZString)+1, uns32(tZString)+1 ] :=
		[
			//tBoolean
			
			[ 	
				&s,			// tBoolean
				&x,			// tEnum	 
				&x,			// tUns8	 
				&x,			// tUns16	 
				&x,			// tUns32	 
				&x,			// tUns64	 
				&x,			// tUns128 
				&x,			// _tByte	 
				&x,			// tWord	 
				&x,			// tDWord	 
				&x,			// tQWord	 
				&x,			// tTByte	 
				&x,			// tLWord	 
				&x,			// tInt8	 
				&x,			// tInt16	 
				&x,			// tInt32	 
				&x,			// tInt64	 
				&x,			// tInt128 
				&x,			// tChar 	 
				&x,			// tWChar	 
				&x,			// tReal32 
				&x,			// tReal64 
				&x,			// tReal80 
				&x,			// tReal128 
				&x,			// tString 
				&x 			// tZString 
			] ,
			
			
			
			//tEnum		
			
			[ 
				&x,   		// tBoolean
				&s,   		// tEnum	 
				&x,   		// tUns8	 
				&x,   		// tUns16	 
				&x,   		// tUns32	 
				&x,   		// tUns64	 
				&x,   		// tUns128 
				&x,			// _tByte	 
				&x,			// tWord	 
				&x,			// tDWord	 
				&x,   		// tQWord	 
				&x,   		// tTByte	 
				&x,   		// tLWord	 
				&x,   		// tInt8	 
				&x,   		// tInt16	 
				&x,   		// tInt32	 
				&x,   		// tInt64	 
				&x,   		// tInt128 
				&x,   		// tChar 	 
				&x,   		// tWChar	 
				&x,   		// tReal32 
				&x,   		// tReal64 
				&x,   		// tReal80 
				&x,   		// tReal128 
				&x,    		// tString 
				&x    		// tZString 
			] ,
			
			//tUns8		
			
			[ 
				&x,   		// tBoolean
				&x,   		// tEnum	 
				&s,   		// tUns8	 
				&Uns8Uns16,	// tUns16	 
				&Uns8Uns32, // tUns32	 
				&Uns8Uns64, // tUns64	 
				&Uns8Uns128,// tUns128 
				&Uns8Byte,  // _tByte	 
				&Uns8Word,  // tWord	 
				&Uns8DWord, // tDWord	 
				&Uns8QWord, // tQWord	 
				&Uns8TByte, // tTByte	 
				&Uns8LWord, // tLWord	 
				&Uns8Int8,  // tInt8	 
				&Uns8Int16, // tInt16	 
				&Uns8Int32, // tInt32	 
				&Uns8Int64, // tInt64	 
				&Uns8Int128,// tInt128 
				&x,   		// tChar 	 
				&x,   		// tWChar	 
				&UnsReal32,	// tReal32 
				&UnsReal64,	// tReal64 
				&UnsReal80,	// tReal80 
				&x,			// tReal128 
				&x,    		// tString 
				&x    		// tZString 
			] ,
			
			//tUns16		
			
			[ 
				&x,   			// tBoolean
				&x,   			// tEnum	 
				&Uns16Uns8, 	// tUns8	 
				&s,				// tUns16	 
				&Uns16Uns32, 	// tUns32	 
				&Uns16Uns64, 	// tUns64	 
				&Uns16Uns128,	// tUns128 
				&Uns16Byte,  	// _tByte	 
				&Uns16Word,  	// tWord	 
				&Uns16DWord, 	// tDWord	 
				&Uns16QWord, 	// tQWord	 
				&Uns16TByte, 	// tTByte	 
				&Uns16LWord, 	// tLWord	 
				&Uns16Int8,  	// tInt8	 
				&Uns16Int16, 	// tInt16	 
				&Uns16Int32, 	// tInt32	 
				&Uns16Int64, 	// tInt64	 
				&Uns16Int128,	// tInt128 
				&x,   			// tChar 	 
				&x,   			// tWChar	 
				&UnsReal32,		// tReal32 
				&UnsReal64,		// tReal64 
				&UnsReal80,		// tReal80 
				&x,				// tReal128 
				&x,    			// tString 
				&x    			// tZString 
			] ,
			
			//tUns32		
			
			[ 
				&x,   			// tBoolean
				&x,   			// tEnum	 
				&Uns32Uns8, 	// tUns8	 
				&Uns32Uns16,	// tUns16	 
				&s,			 	// tUns32	 
				&Uns32Uns64, 	// tUns64	 
				&Uns32Uns128,	// tUns128 
				&Uns32Byte,  	// _tByte	 
				&Uns32Word,  	// tWord	 
				&Uns32DWord, 	// tDWord	 
				&Uns32QWord, 	// tQWord	 
				&Uns32TByte, 	// tTByte	 
				&Uns32LWord, 	// tLWord	 
				&Uns32Int8,  	// tInt8	 
				&Uns32Int16, 	// tInt16	 
				&Uns32Int32, 	// tInt32	 
				&Uns32Int64, 	// tInt64	 
				&Uns32Int128,	// tInt128 
				&x,   			// tChar 	 
				&x,   			// tWChar	 
				&UnsReal32,		// tReal32 
				&UnsReal64,		// tReal64 
				&UnsReal80,		// tReal80 
				&x,				// tReal128 
				&x,    			// tString 
				&x    			// tZString 
			] ,
			
			//tUns64		
			
			[ 
				&x,   			// tBoolean
				&x,   			// tEnum	 
				&Uns64Uns8, 	// tUns8	 
				&Uns64Uns16,	// tUns16	 
				&Uns64Uns32, 	// tUns32	 
				&s,			 	// tUns64	 
				&Uns64Uns128,	// tUns128 
				&Uns64Byte,  	// _tByte	 
				&Uns64Word,  	// tWord	 
				&Uns64DWord, 	// tDWord	 
				&Uns64QWord, 	// tQWord	 
				&Uns64TByte, 	// tTByte	 
				&Uns64LWord, 	// tLWord	 
				&Uns64Int8,  	// tInt8	 
				&Uns64Int16, 	// tInt16	 
				&Uns64Int32, 	// tInt32	 
				&Uns64Int64, 	// tInt64	 
				&Uns64Int128,	// tInt128 
				&x,   			// tChar 	 
				&x,   			// tWChar	 
				&UnsReal32,		// tReal32 
				&UnsReal64,		// tReal64 
				&UnsReal80,		// tReal80 
				&x,				// tReal128 
				&x,    			// tString 
				&x    			// tZString 
			] ,
			
			//tUns128	
			
			[ 
				&x,   			// tBoolean
				&x,   			// tEnum	 
				&Uns128Uns8, 	// tUns8	 
				&Uns128Uns16,	// tUns16	 
				&Uns128Uns32, 	// tUns32	 
				&Uns128Uns64,	// tUns64	 
				&s,				// tUns128 
				&Uns64Byte,  	// _tByte	 
				&Uns64Word,  	// tWord	 
				&Uns64DWord, 	// tDWord	 
				&Uns64QWord, 	// tQWord	 
				&Uns64TByte, 	// tTByte	 
				&Uns64LWord, 	// tLWord	 
				&Uns64Int8,  	// tInt8	 
				&Uns64Int16, 	// tInt16	 
				&Uns64Int32, 	// tInt32	 
				&Uns64Int64, 	// tInt64	 
				&Uns64Int128,	// tInt128 
				&x,   			// tChar 	 
				&x,   			// tWChar	 
				&UnsReal32,		// tReal32 
				&UnsReal64,		// tReal64 
				&UnsReal80,		// tReal80 
				&x,				// tReal128
				&x,    			// tString 
				&x    			// tZString 
			] ,
			
			//_tByte		
			
			[ 
				&x,   			// tBoolean
				&x,   			// tEnum	 
				&ByteUns8,		// tUns8	 
				&ByteUns16,		// tUns16	 
				&ByteUns32,		// tUns32	 
				&ByteUns64,		// tUns64	 
				&ByteUns128,	// tUns128 
				&s,				// _tByte	 
				&ByteWord,		// tWord	 
				&ByteDWord,		// tDWord	 
				&ByteQWord,		// tQWord	 
				&ByteTByte,		// tTByte	 
				&ByteLWord,		// tLWord	 
				&ByteInt8,		// tInt8	 
				&ByteInt16,		// tInt16	 
				&ByteInt32,		// tInt32	 
				&ByteInt64,		// tInt64	 
				&ByteInt128,	// tInt128 
				&x,   			// tChar 	 
				&x,   			// tWChar	 
				&UnsReal32,		// tReal32 
				&UnsReal64,		// tReal64 
				&UnsReal80,		// tReal80 
				&x,				// tReal128 
				&x,    			// tString 
				&x    			// tZString 
			] ,
			
			//tWord		
			
			[ 
				&x,   			// tBoolean
				&x,   			// tEnum	 
				&WordUns8,		// tUns8	 
				&WordUns16,		// tUns16	 
				&WordUns32,		// tUns32	 
				&WordUns64,		// tUns64	 
				&WordUns128,	// tUns128 
				&WordByte,		// _tByte	 
				&s,				// tWord	 
				&WordDWord,		// tDWord	 
				&WordQWord,		// tQWord	 
				&WordTByte,		// tTByte	 
				&WordLWord,		// tLWord	 
				&WordInt8,		// tInt8	 
				&WordInt16,		// tInt16	 
				&WordInt32,		// tInt32	 
				&WordInt64,		// tInt64	 
				&WordInt128,	// tInt128 
				&x,   			// tChar 	 
				&x,   			// tWChar	 
				&UnsReal32,		// tReal32 
				&UnsReal64,		// tReal64 
				&UnsReal80,		// tReal80 
				&x,				// tReal128 
				&x,    			// tString 
				&x    			// tZString 
			] ,
			
			//tDWord		
			
			[ 
				&x,   			// tBoolean
				&x,   			// tEnum	 
				&DWordUns8,		// tUns8	 
				&DWordUns16,	// tUns16	 
				&DWordUns32,	// tUns32	 
				&DWordUns64,	// tUns64	 
				&DWordUns128,	// tUns128 
				&DWordByte,		// _tByte	 
				&DWordWord,		// tWord	 
				&s,				// tDWord	 
				&DWordQWord,	// tQWord	 
				&DWordTByte,	// tTByte	 
				&DWordLWord,	// tLWord	 
				&DWordInt8,		// tInt8	 
				&DWordInt16,	// tInt16	 
				&DWordInt32,	// tInt32	 
				&DWordInt64,	// tInt64	 
				&DWordInt128,	// tInt128 
				&x,   			// tChar 	 
				&x,   			// tWChar	 
				&UnsReal32,		// tReal32 
				&UnsReal64,		// tReal64 
				&UnsReal80,		// tReal80 
				&x,				// tReal128 
				&x,    			// tString 
				&x    			// tZString 
			] ,
			
			//tQWord		
			
			[ 
				&x,   			// tBoolean
				&x,   			// tEnum	 
				&QWordUns8,		// tUns8	 
				&QWordUns16,	// tUns16	 
				&QWordUns32,	// tUns32	 
				&QWordUns64,	// tUns64	 
				&QWordUns128,	// tUns128 
				&QWordByte,		// _tByte	 
				&QWordWord,		// tWord	 
				&QWordDWord,	// tDWord	 
				&s,				// tQWord	 
				&QWordTByte,	// tTByte	 
				&QWordLWord,	// tLWord	 
				&QWordInt8,		// tInt8	 
				&QWordInt16,	// tInt16	 
				&QWordInt32,	// tInt32	 
				&QWordInt64,	// tInt64	 
				&QWordInt128,	// tInt128 
				&x,   			// tChar 	 
				&x,   			// tWChar	 
				&UnsReal32,		// tReal32 
				&UnsReal64,		// tReal64 
				&UnsReal80,		// tReal80 
				&x,				// tReal128 
				&x,    			// tString 
				&x    			// tZString 
			] ,
			
			//tTByte		
			
			[ 
				&x,   			// tBoolean
				&x,   			// tEnum	 
				&TByteUns8,		// tUns8	 
				&TByteUns16,	// tUns16	 
				&TByteUns32,	// tUns32	 
				&TByteUns64,	// tUns64	 
				&TByteUns128,	// tUns128 
				&TByteByte,		// _tByte	 
				&TByteWord,		// tWord	 
				&TByteDWord,	// tDWord	 
				&TByteQWord,	// tQWord	 
				&s,				// tTByte	 
				&TByteLWord,	// tLWord	 
				&TByteInt8,		// tInt8	 
				&TByteInt16,	// tInt16	 
				&TByteInt32,	// tInt32	 
				&TByteInt64,	// tInt64	 
				&TByteInt128,	// tInt128 
				&x,   			// tChar 	 
				&x,   			// tWChar	 
				&UnsReal32,		// tReal32 
				&UnsReal64,		// tReal64 
				&UnsReal80,		// tReal80 
				&x,				// tReal128 
				&x,    			// tString 
				&x    			// tZString 
			] ,
			
			//tLWord		
			
			[ 
				&x,   // tBoolean
				&x,   // tEnum	 
				&LWordUns8,		// tUns8	 
				&LWordUns16,	// tUns16	 
				&LWordUns32,	// tUns32	 
				&LWordUns64,	// tUns64	 
				&LWordUns128,	// tUns128 
				&LWordByte,		// _tByte	 
				&LWordWord,		// tWord	 
				&LWordDWord,	// tDWord	 
				&LWordQWord,	// tQWord	 
				&LWordTByte,	// tTByte	 
				&s,				// tLWord	 
				&LWordInt8,		// tInt8	 
				&LWordInt16,	// tInt16	 
				&LWordInt32,	// tInt32	 
				&LWordInt64,	// tInt64	 
				&LWordInt128,	// tInt128 
				&x,   			// tChar 	 
				&x,   			// tWChar	 
				&UnsReal32,		// tReal32 
				&UnsReal64,		// tReal64 
				&UnsReal80,		// tReal80 
				&x,				// tReal128 
				&x,    			// tString 
				&x    			// tZString 
			] ,
			
			//tInt8		
			
			[ 
				&x,   			// tBoolean
				&x,   			// tEnum	 
				&Int8Uns8,		// tUns8	 
				&Int8Uns16,  	// tUns16	 
				&Int8Uns32,		// tUns32	 
				&Int8Uns64,		// tUns64	 
				&Int8Uns128,	// tUns128 
				&Int8Byte,		// _tByte	 
				&Int8Word,		// tWord	 
				&Int8DWord,		// tDWord	 
				&Int8QWord,		// tQWord	 
				&Int8TByte,		// tTByte	 
				&Int8LWord,		// tLWord	 
				&s,   			// tInt8	 
				&Int8Int16,		// tInt16	 
				&Int8Int32,		// tInt32	 
				&Int8Int64,		// tInt64	 
				&Int8Int128,	// tInt128 
				&x,   			// tChar 	 
				&x,   			// tWChar	 
				&IntReal32,		// tReal32 
				&IntReal64,		// tReal64 
				&IntReal80,		// tReal80 
				&x,				// tReal128 
				&x,    			// tString 
				&x    			// tZString 
			] ,
			
			//tInt16		
			
			[ 
				&x,				// tBoolean
				&x,				// tEnum	 
				&Int16Uns8,		// tUns8	 
				&Int16Uns16,  	// tUns16	 
				&Int16Uns32,	// tUns32	 
				&Int16Uns64,	// tUns64	 
				&Int16Uns128,	// tUns128 
				&Int16Byte,		// _tByte	 
				&Int16Word,		// tWord	 
				&Int16DWord,	// tDWord	 
				&Int16QWord,	// tQWord	 
				&Int16TByte,	// tTByte	 
				&Int16LWord,	// tLWord	 
				&Int16Int8,		// tInt8	 
				&s,				// tInt16	 
				&Int16Int32,	// tInt32	 
				&Int16Int64,	// tInt64	 
				&Int16Int128,	// tInt128 
				&x,				// tChar 	 
				&x,				// tWChar	 
				&IntReal32,		// tReal32 
				&IntReal64,		// tReal64 
				&IntReal80,		// tReal80 
				&x,				// tReal128 
				&x,				// tString 
				&x				// tZString 
			] ,
			
			//tInt32		
			
			[ 
				&x,				// tBoolean
				&x,				// tEnum	 
				&Int32Uns8,		// tUns8	 
				&Int32Uns16,  	// tUns16	 
				&Int32Uns32,	// tUns32	 
				&Int32Uns64,	// tUns64	 
				&Int32Uns128,	// tUns128 
				&Int32Byte,		// _tByte	 
				&Int32Word,		// tWord	 
				&Int32DWord,	// tDWord	 
				&Int32QWord,	// tQWord	 
				&Int32TByte,	// tTByte	 
				&Int32LWord,	// tLWord	 
				&Int32Int8,		// tInt8	 
				&Int32Int16,	// tInt16	 
				&s,				// tInt32	 
				&Int32Int64,	// tInt64	 
				&Int32Int128,	// tInt128 
				&x,				// tChar 	 
				&x,				// tWChar	 
				&IntReal32,		// tReal32 
				&IntReal64,		// tReal64 
				&IntReal80,		// tReal80 
				&x,				// tReal128 
				&x,				// tString 
				&x 				// tZString 
			] ,
			
			//tInt64		
			
			[ 
				&x,				// tBoolean
				&x,				// tEnum	 
				&Int64Uns8,		// tUns8	 
				&Int64Uns16,  	// tUns16	 
				&Int64Uns32,	// tUns32	 
				&Int64Uns64,	// tUns64	 
				&Int64Uns128,	// tUns128 
				&Int64Byte,		// _tByte	 
				&Int64Word,		// tWord	 
				&Int64DWord,	// tDWord	 
				&Int64QWord,	// tQWord	 
				&Int64TByte,	// tTByte	 
				&Int64LWord,	// tLWord	 
				&Int64Int8,		// tInt8	 
				&Int64Int16,	// tInt16	 
				&Int64Int32,	// tInt32	 
				&s,				// tInt64	 
				&Int64Int128,	// tInt128 
				&x,				// tChar 	 
				&x,				// tWChar	 
				&IntReal32,		// tReal32 
				&IntReal64,		// tReal64 
				&IntReal80,		// tReal80 
				&x,				// tReal128 
				&x,				// tString 
				&x 				// tZString 
			] ,
			
			//tInt128	
			
			[ 
				&x,   			// tBoolean
				&x,   			// tEnum	 
				&Int128Uns8,	// tUns8	 
				&Int128Uns16,  	// tUns16	 
				&Int128Uns32,	// tUns32	 
				&Int128Uns64,	// tUns64	 
				&Int128Uns128,	// tUns128 
				&Int128Byte,	// _tByte	 
				&Int128Word,	// tWord	 
				&Int128DWord,	// tDWord	 
				&Int128QWord,	// tQWord	 
				&Int128TByte,	// tTByte	 
				&Int128LWord,	// tLWord	 
				&Int128Int8,	// tInt8	 
				&Int128Int16,	// tInt16	 
				&Int128Int32,	// tInt32	 
				&Int128Int64,	// tInt64	 
				&s,   			// tInt128 
				&x,   			// tChar 	 
				&x,   			// tWChar	 
				&IntReal32,		// tReal32 
				&IntReal64,		// tReal64 
				&IntReal80,		// tReal80 
				&x,				// tReal128 
				&x,    			// tString 
				&x    			// tZString 
			] ,
			
			//tChar 		
			
			[ 
				&x,				// tBoolean
				&x,				// tEnum	 
				&x,				// tUns8	 
				&x,				// tUns16	 
				&x,				// tUns32	 
				&x,				// tUns64	 
				&x,				// tUns128 
				&x,				// _tByte	 
				&x,				// tWord	 
				&x,				// tDWord	 
				&x,				// tQWord	 
				&x,				// tTByte	 
				&x,				// tLWord	 
				&x,				// tInt8	 
				&x,				// tInt16	 
				&x,				// tInt32	 
				&x,				// tInt64	 
				&x,				// tInt128 
				&s,				// tChar 	 
				&CharWChar,		// tWChar	 
				&x,				// tReal32 
				&x,				// tReal64 
				&x,				// tReal80 
				&x,				// tReal128 
				&CharString,	// tString 
				&CharString		// tZString 
			] ,
			
			//tWChar		
			
			[ 
				&x,				// tBoolean
				&x,				// tEnum	 
				&x,				// tUns8	 
				&x,				// tUns16	 
				&x,				// tUns32	 
				&x,				// tUns64	 
				&x,				// tUns128 
				&x,				// _tByte	 
				&x,				// tWord	 
				&x,				// tDWord	 
				&x,				// tQWord	 
				&x,				// tTByte	 
				&x,				// tLWord	 
				&x,				// tInt8	 
				&x,				// tInt16	 
				&x,				// tInt32	 
				&x,				// tInt64	 
				&x,				// tInt128 
				&WCharChar,		// tChar 	 
				&s,	   			// tWChar	 
				&x,	   			// tReal32 
				&x,	   			// tReal64 
				&x,	   			// tReal80 
				&x,	   			// tReal128 
				&x,	   			// tString 
				&x 	   			// tZString 
			] ,
			
			//tReal32	
			
			[ 
				&x,			// tBoolean
				&x,			// tEnum	 
				&Real32Uns,	// tUns8	 
				&Real32Uns,	// tUns16	 
				&Real32Uns,	// tUns32	 
				&Real32Uns,	// tUns64	 
				&Real32Uns,	// tUns128 
				&Real32Uns,	// _tByte	 
				&Real32Uns,	// tWord	 
				&Real32Uns,	// tDWord	 
				&Real32Uns,	// tQWord	 
				&Real32Uns,	// tTByte	 
				&Real32Uns,	// tLWord	 
				&Real32Int,	// tInt8	 
				&Real32Int,	// tInt16	 
				&Real32Int,	// tInt32	 
				&Real32Int,	// tInt64	 
				&Real32Int,	// tInt128 
				&x,			// tChar 	 
				&x,			// tWChar	 
				&s,			// tReal32 
				&Real3264,	// tReal64 
				&Real3280,	// tReal80 
				&x,			// tReal128 
				&x,			// tString 
				&x 			// tZString 
			] ,
			
			//tReal64 	
			
			[ 
				&x,			// tBoolean
				&x,			// tEnum	 
				&Real64Uns,	// tUns8	 
				&Real64Uns,	// tUns16	 
				&Real64Uns,	// tUns32	 
				&Real64Uns,	// tUns64	 
				&Real64Uns,	// tUns128 
				&Real64Uns,	// _tByte	 
				&Real64Uns,	// tWord	 
				&Real64Uns,	// tDWord	 
				&Real64Uns,	// tQWord	 
				&Real64Uns,	// tTByte	 
				&Real64Uns,	// tLWord	 
				&Real64Int,	// tInt8	 
				&Real64Int,	// tInt16	 
				&Real64Int,	// tInt32	 
				&Real64Int,	// tInt64	 
				&Real64Int,	// tInt128 
				&x,			// tChar 	 
				&x,			// tWChar	 
				&Real6432,	// tReal32 
				&s,			// tReal64 
				&Real6480,	// tReal80 
				&x,			// tReal128 
				&x,			// tString 
				&x 			// tZString 
			] ,
			
			//tReal80	
			
			[ 
				&x,				// tBoolean
				&x,				// tEnum	 
				&Real80Uns,		// tUns8	 
				&Real80Uns,		// tUns16	 
				&Real80Uns,		// tUns32	 
				&Real80Uns,		// tUns64	 
				&Real80Uns,		// tUns128 
				&Real80Uns,		// _tByte	 
				&Real80Uns,		// tWord	 
				&Real80Uns,		// tDWord	 
				&Real80Uns,		// tQWord	 
				&Real80Uns,		// tTByte	 
				&Real80Uns,		// tLWord	 
				&Real80Int,		// tInt8	 
				&Real80Int,		// tInt16	 
				&Real80Int,		// tInt32	 
				&Real80Int,		// tInt64	 
				&Real80Int,		// tInt128 
				&x,				// tChar 	 
				&x,				// tWChar	 
				&Real8032,		// tReal32 
				&Real8064,		// tReal64 
				&s,				// tReal80 
				&x,				// tReal128 
				&x,				// tString 
				&x 				// tZString 
			] ,
			
			//tReal128	
			
			[ 
				&x,				// tBoolean
				&x,				// tEnum	 
				&x,				// tUns8	 
				&x,				// tUns16	 
				&x,				// tUns32	 
				&x,				// tUns64	 
				&x,				// tUns128 
				&x,				// _tByte	 
				&x,				// tWord	 
				&x,				// tDWord	 
				&x,				// tQWord	 
				&x,				// tTByte	 
				&x,				// tLWord	 
				&x,				// tInt8	 
				&x,				// tInt16	 
				&x,				// tInt32	 
				&x,				// tInt64	 
				&x,				// tInt128 
				&x,				// tChar 	 
				&x,				// tWChar	 
				&x,				// tReal32 
				&x,				// tReal64 
				&s,				// tReal80 
				&x,				// tReal128 
				&x,				// tString 
				&x 				// tZString 
			] ,
			
			//tString	
			
			[ 
				&x,   			// tBoolean
				&x,   			// tEnum	 
				&x,   			// tUns8	 
				&x,   			// tUns16	 
				&x,   			// tUns32	 
				&x,   			// tUns64	 
				&x,   			// tUns128 
				&x,   			// _tByte	 
				&x,   			// tWord	 
				&x,   			// tDWord	 
				&x,   			// tQWord	 
				&x,   			// tTByte	 
				&x,   			// tLWord	 
				&x,   			// tInt8	 
				&x,   			// tInt16	 
				&x,   			// tInt32	 
				&x,   			// tInt64	 
				&x,   			// tInt128 
				&StringChar,	// tChar 	 
				&x,   			// tWChar	 
				&x,   			// tReal32 
				&x,   			// tReal64 
				&x,   			// tReal80 
				&x,   			// tReal128 
				&s,    			// tString 
				&s    			// tZString 
			],
			
			//tZString	
			
			[ 
				&x,   			// tBoolean
				&x,   			// tEnum	 
				&x,   			// tUns8	 
				&x,   			// tUns16	 
				&x,   			// tUns32	 
				&x,   			// tUns64	 
				&x,   			// tUns128 
				&x,   			// _tByte	 
				&x,   			// tWord	 
				&x,   			// tDWord	 
				&x,   			// tQWord	 
				&x,   			// tTByte	 
				&x,   			// tLWord	 
				&x,   			// tInt8	 
				&x,   			// tInt16	 
				&x,   			// tInt32	 
				&x,   			// tInt64	 
				&x,   			// tInt128 
				&StringChar,	// tChar 	 
				&x,   			// tWChar	 
				&x,   			// tReal32 
				&x,   			// tReal64 
				&x,   			// tReal80 
				&x,   			// tReal128 
				&s,    			// tString 
				&s    			// tZString 
			]
		];
		
begin MakeCompAsm;

	push( ebx );
	push( ecx );
	push( edx );
	push( edi );
	push( esi );
	begin mca;
	

		mov( lpType, ebx );
		mov( rpType, ecx );
		mov( lType, edi );
		mov( rType, esi );
		movzx( lpt, eax );
		movzx( rpt, edx );
		
		cmp( al, tPointer );
		je LPointer;
		cmp( dl, tPointer );
		je RPointer;
		
		cmp( al, tProcptr );
		je LProcptr;
		cmp( dl, tProcptr );
		je RProcptr;
		
		if( al > tString || dl > tString ) then
		
			xor( eax, eax );
			exit mca;
			
		endif;
		intmul( uns32( tZString ) + 1, eax );
		add( edx, eax );
		jmp( jmpTbl[ eax*4 ] );
						
		
		// Handle pointers here:
		
		LPointer:
			cmp( dl, tString );
			je Success;
			cmp( dl, tDWord );
			je Success;
			cmp( dl, tPointer );
			je Success;
			cmp( dl, tProcptr );
			je Success;
			xor( eax, eax );
			exit mca;
			
		RPointer:
			cmp( al, tString );
			je Success;
			cmp( al, tDWord );
			je Success;
			cmp( al, tPointer );
			je Success;
			cmp( al, tProcptr );
			je Success;
			xor( eax, eax );
			exit mca;
		
		LProcptr:
			cmp( dl, tDWord );
			je Success;
			cmp( dl, tPointer );
			je Success;
			cmp( dl, tProcptr );
			je Success;
			xor( eax, eax );
			exit mca;
			
		RProcptr:
			cmp( al, tDWord );
			je Success;
			cmp( al, tPointer );
			je Success;
			cmp( al, tProcptr );
			je Success;
			xor( eax, eax );
			exit mca;
			
		
		
			
		// Handle char<->WChar translations here.
			
		CharWChar:
			mov( lData, eax );
			mov( 0, (type byte [eax+1]) );
			mov( tWChar, lpt );
			mov( &wchar_ste, lt );
		
		Success:
			mov( 1, eax );
			exit mca;
			
			
		WCharChar:
			mov( rData, eax );
			mov( 0, (type byte [eax+1]) );
			mov( tWChar, rpt );
			mov( &wchar_ste, rt );
			mov( 1, eax );
			exit mca;
			
			
		
		// Handle char->String translations here:
		
		CharString:

			malloc2( 8 );
			mov( lData, edx );
			mov( [edx], ch );
			mov( ch, [eax] );
			mov( 0, (type byte [eax+1]));
			mov( eax, [edx]);
			mov( tString, lpt );
			mov( &string_ste, lt );
			mov( 1, eax );
			exit mca;
			
		
		StringChar:

			malloc2( 8 );
			mov( rData, edx );
			mov( [edx], bh );
			mov( bh, [eax] );
			mov( 0, (type byte [eax+1]));
			mov( eax, [edx]);
			mov( tString, rpt );
			mov( &string_ste, rt );
			mov( 1, eax );
			exit mca;
		



		// Left operand is one of the Unsigned or Hex types (up to 64 bits)
		// and the right operand is a real32 operand.  Verify that the
		// unsigned operand is 23 bits or less (the real32 mantissa is
		// 23 bits).  Reject the conversion if not, since we'd lose precision
		// by doing the conversion.
		
		UnsReal32:
			mov( lData, eax );				// Verify that it fits into
			if								// 23 bits.
			( 
					(type dword [eax+4]) = 0
				&&	(type dword [eax+8]) = 0
				&&	(type dword [eax+12]) = 0 
			) then
			
				test( $FF80, (type word [eax+2]) );
				if( @z ) then
					 
					fild( (type dword [eax]) );
					fstp( (type real32 [eax]));
					mov( tReal32, lpt );
					mov( &real32_ste, lt );
					mov( 1, eax );
					exit mca;
					
				endif;
			
			endif;
			yyerror
			( 
				"Unsigned value is out of range, cannot convert to real32"
			);
			xor( eax, eax );
			exit mca;
			
			
		
		
		// Right operand is one of the Unsigned or Hex types (up to 64 bits)
		// and the left operand is a real32 operand.  Verify that the
		// unsigned operand is 23 bits or less (the real32 mantissa is
		// 23 bits).  Reject the conversion if not, since we'd lose precision
		// by doing the conversion.
		
		Real32Uns:
			mov( rData, eax );				// Verify that it fits into
			if								// 23 bits.
			( 
					(type dword [eax+4]) = 0
				&&	(type dword [eax+8]) = 0
				&&	(type dword [eax+12]) = 0 
			) then
			
				test( $FF80, (type word [eax+2]) );
				if( @z ) then
					 
					fild( (type dword [eax]) );
					fstp( (type real32 [eax]));
					mov( tReal32, rpt );
					mov( &real32_ste, rt );
					mov( 1, eax );
					exit mca;
					
				endif;
			
			endif;
			yyerror
			( 
				"Unsigned value is out of range, cannot convert to real32"
			);
			xor( eax, eax );
			exit mca;
			
			
			
		// Left operand is INTxx and right operand is real32.
		// We need to see if the signed left operand will fit
		// into 24 bits (the real32 mantissa) before doing the
		// conversion.  If not, reject an automatic conversion
		// because we'd lose precision.  The following code
		// uses sign extension to verify that bits 24..63 are
		// the same as bit 23.
		
		IntReal32:
			mov( lData, edx );
			fild( (type qword [edx]) );
			fstp( (type real32 [edx]));
			mov( tReal32, lpt );
			mov( &real32_ste, lt );
			mov( 1, eax );
			exit mca;
			
			
		
		// As above, but we've swapped the operands.
		
		Real32Int:
			mov( rData, edx );
			fild( (type qword [edx]) );
			fstp( (type real32 [edx]));
			mov( tReal32, rpt );
			mov( &real32_ste, rt );
			mov( 1, eax );
			exit mca;
			
			
			
		
		// Left operand is real32, right operand is real64.
		// Convert the left operand to real64.
		
		Real3264:
			mov( lData, eax );
			fld( (type real32 [eax]) );
			fstp( (type real64 [eax]));
			mov( tReal64, lpt );
			mov( &real64_ste, lt );
			mov( 1, eax );
			exit mca;
			
			
		
		
		// Left operand is real32, right operand is real80.
		// Convert the left operand to real80.
		
		Real3280:
			mov( lData, eax );
			fld( (type real32 [eax]) );
			fstp( (type real80 [eax]));
			mov( tReal80, lpt );
			mov( &real80_ste, lt );
			mov( 1, eax );
			exit mca;
			
			
		
		
			
		
		
		// Left operand is one of the Unsigned or Hex types (up to 64 bits)
		// and the right operand is a real64 operand.  Verify that the
		// unsigned operand is 52 bits or less (the real64 mantissa is
		// 52 bits).  Reject the conversion if not, since we'd lose precision
		// by doing the conversion.
		
		UnsReal64:
			mov( lData, edx );
			mov( [edx+6], eax ); 						
			and( $FFF0, eax);					// Verify that it fits
			or( [edx+8], eax );					// into 52 bits.
			or( [edx+12], eax );
			if( @z ) then
			
				fild( (type qword [edx]) );
				fstp( (type real64 [edx]));
				mov( tReal64, lpt );
				mov( &real64_ste, lt );
				mov( 1, eax );
				exit mca;
			
			endif;
			yyerror
			( 
				"Unsigned value is out of range, cannot convert to real64"
			);
			xor( eax, eax );
			exit mca;
			
			
			
		
		
		// Right operand is one of the Unsigned or Hex types (up to 64 bits)
		// and the left operand is a real64 operand.  Verify that the
		// unsigned operand is 52 bits or less (the real64 mantissa is
		// 52 bits).  Reject the conversion if not, since we'd lose precision
		// by doing the conversion.
		
		Real64Uns:
			mov( rData, edx );
			mov( [edx+6], ax ); 						
			and( $FFF0, eax);					// Verify that it fits
			or( [edx+8], eax );					// into 52 bits.
			or( [edx+12], eax );
			if( @z ) then
			
				fild( (type qword [edx]) );
				fstp( (type real64 [edx]));
				mov( tReal64, rpt );
				mov( &real64_ste, rt );
				mov( 1, eax );
				exit mca;
			
			endif;
			yyerror
			( 
				"Unsigned value is out of range, cannot convert to real64"
			);
			xor( eax, eax );
			exit mca;
			

			
			
		// Left operand is one of the signed types (up to 64 bits)
		// and the right operand is a real64 operand.  Verify that the
		// unsigned operand is 52 bits or less (the real64 mantissa is
		// 52 bits).  Reject the conversion if not, since we'd lose precision
		// by doing the conversion.
		
		IntReal64:
			mov( lData, ecx );					// Verify that the number fits
			movsx( (type word [ecx+6]), eax );	// into 52 bits.
			cdq();
			and( $FFF8, ax );
			if
			( 
					( @z || ax = $FFF8 )
				&&	edx = [ecx+8]
				&&	edx = [ecx+12] 
			) then
					 
				fild( (type qword [ecx]) );
				fstp( (type real64 [ecx]));
				mov( tReal64, lpt );
				mov( &real64_ste, lt );
				mov( 1, eax );
				exit mca;
					
			endif;
			yyerror
			( 
				"Unsigned value is out of range, cannot convert to real64"
			);
			xor( eax, eax );
			exit mca;
			

		
		// As above, but reverse the operands.	
			
		Real64Int:
			mov( rData, ebx );					// Verify that the number fits
			movsx( (type word [ebx+6]), eax );	// into 52 bits.
			cdq();
			and( $FFF8, ax );
			if
			( 
					( @z || ax = $FFF8 )
				&&	edx = [ebx+8]
				&&	edx = [ebx+12] 
			) then
					 
				fild( (type qword [ebx]) );
				fstp( (type real64 [ebx]));
				mov( tReal64, rpt );
				mov( &real64_ste, rt );
				mov( 1, eax );
				exit mca;
					
			endif;
			yyerror
			( 
				"Unsigned value is out of range, cannot convert to real64"
			);
			xor( eax, eax );
			exit mca;

			
			
		// Left operand is real64, right operand is real32.
		// Convert the right operand to real64.
		
		Real6432:
			mov( rData, eax );
			fld( (type real32 [eax]) );
			fstp( (type real64 [eax]));
			mov( tReal64, rpt );
			mov( &real64_ste, rt );
			mov( 1, eax );
			exit mca;
			
			
		
		// Left operand is real64, right operand is real80.
		// Convert the left operand to real80.
		
		Real6480:
			mov( lData, eax );
			fld( (type real64 [eax]) );
			fstp( (type real80 [eax]));
			mov( tReal80, lpt );
			mov( &real80_ste, lt );
			mov( 1, eax );
			exit mca;
			
			
			
			
		
		
		// Left operand is one of the Unsigned or Hex types (up to 64 bits)
		// and the right operand is a real64 operand.  Verify that the
		// unsigned operand is 63 bits or less (the real80 mantissa is
		// 64 bits, but the FILD instruction expects a signed operand).  
		// Reject the conversion if not, since FILD would treat the value
		// as signed if the H.O. bit is set.
		
		UnsReal80:
			mov( lData, ecx );						// Verify that it fits
			movsx( (type byte [ecx+7]), eax );		// into 63 bits.
			cdq();
			if( edx = 0 && edx = [ecx+8] && edx = [ecx+12] ) then
			
				fild( (type qword [ecx]) );
				fstp( (type real80 [ecx]));
				mov( tReal80, lpt );
				mov( &real80_ste, lt );
				mov( 1, eax );
				exit mca;
					
			
			endif;
			yyerror
			( 
				"Unsigned value is out of range, cannot convert to real80"
			);
			xor( eax, eax );
			exit mca;
			
			
			
			
		// As above, but reverse the operands:
		
		Real80Uns:
			mov( rData, ebx );					// Verify that it fits into
			movsx( (type byte [ebx+7]), eax );	// into 63 bits.
			cdq();
			if( edx = 0 && edx = [ebx+8] && edx = [ebx+12] ) then
			
				fild( (type qword [ebx]) );
				fstp( (type real80 [ebx]));
				mov( tReal80, rpt );
				mov( &real80_ste, rt );
				mov( 1, eax );
				exit mca;
					
			
			endif;
			yyerror
			( 
				"Unsigned value is out of range, cannot convert to real80"
			);
			xor( eax, eax );
			exit mca;
			
			
			
		
		// Left operand is one of the signed types
		// and the right operand is a real80 operand.
		// Be sure the result fits into 64 bits.
		
		
		IntReal80:
			mov( lData, ecx );					// Verify that it fits into
			movsx( (type byte [ecx+7]), eax );	// into 63 bits.
			cdq();
			if
			( 
					( edx = 0 || edx = -1) 
				&&	edx = [ecx+8] 
				&&	edx = [ecx+12] 
			) then

				fild( (type qword [ecx]) );
				fstp( (type real80 [ecx]));
				mov( tReal80, lpt );
				mov( &real80_ste, lt );
				mov( 1, eax );
				exit mca;
			
			endif;			
			yyerror
			( 
				"Unsigned value is out of range, cannot convert to real80"
			);
			xor( eax, eax );
			exit mca;
			
		
		
		// As above, but reverse the operands:		
		
		Real80Int:
			mov( rData, ebx );					// Verify that it fits into
			movsx( (type byte [ebx+7]), eax );	// into 63 bits.
			cdq();
			if
			( 
					( edx = 0 || edx = -1) 
				&&	edx = [ebx+8] 
				&&	edx = [ebx+12] 
			) then

				fild( (type qword [ebx]) );
				fstp( (type real80 [ebx]));
				mov( tReal80, rpt );
				mov( &real80_ste, rt );
				mov( 1, eax );
				exit mca;
			
			endif;			
			yyerror
			( 
				"Unsigned value is out of range, cannot convert to real80"
			);
			xor( eax, eax );
			exit mca;
			
			
			
			
		// Left operand is real80, right is real32.  Convert
		// the right operand to real80.
		
		Real8032:
			mov( rData, eax );
			fld( (type real32 [eax]) );
			fstp( (type real80 [eax]));
			mov( tReal80, rpt );
			mov( &real80_ste, rt );
			mov( 1, eax );
			exit mca;
			
			
		
		
		// Left operand is real80, right is real64.  Convert
		// the right operand to real80.
		
		Real8064:
		
			mov( rData, eax );
			fld( (type real64 [eax]) );
			fstp( (type real80 [eax]));
			mov( tReal80, rpt );
			mov( &real80_ste, rt );
			mov( 1, eax );
			exit mca;
			
		
		
		// Byte<->Uns8 conversions always produce Uns8.
			
				
		Uns8Byte:
		ByteUns8:  
			mov( tUns8, rpt );
			mov( &uns8_ste, rt );
			mov( tUns8, lpt );
			mov( &uns8_ste, lt );
			mov( 1, eax );
			exit mca;
			
			
		// If we've got a two unsigned operands (16 bits or less) and at least
		// one of them is Uns16, then convert both operands
		// to Uns16. 
			
		Uns8Word:  
		Uns16Word:
		Uns8Uns16:
		ByteUns16:
		WordUns16: 
		Uns16Uns8:
		Uns16Byte:
		WordUns8:  
			mov( tUns16, lpt );
			mov( &uns16_ste, lt );
			mov( tUns16, rpt );
			mov( &uns16_ste, rt );
			mov( 1, eax );
			exit mca;
			
			
		// If we've got two unsigned or hex operands (32 bits or less) 
		// and at least one of them is UNSxx and at least one of them
		// is 32 bits, then convert both of them to Uns32:
			
		Uns8DWord: 
		Uns16DWord:
		Uns32DWord:
		ByteUns32:
		Uns8Uns32: 
		Uns16Uns32: 
		WordUns32:
		DWordUns32:
		Uns32Uns8:
		Uns32Byte:  
		Uns32Word:
		Uns32Uns16:
		DWordUns8:
		DWordUns16:
			mov( tUns32, lpt );
			mov( &uns32_ste, lt );
			mov( tUns32, rpt );
			mov( &uns32_ste, rt );
			mov( 1, eax );
			exit mca;
	
				
			
				
			
		
		// A mixture of UNSxx and INTxx always produces INTxx.
		// Uns8Int8 produces INT16 if the uns8 value is >= $80,
		// else it produces an INT8 value.
				
		Uns8Int8:
			mov( lData, eax );
			if( (type byte [eax]) >= $80 ) then

				mov( tInt16, lpt );
				mov( &int16_ste, lt );
				mov( tInt16, rpt );
				mov( &int16_ste, rt );
			
			else
			  
				mov( tInt8, lpt );
				mov( &int8_ste, lt );
			
			endif;
			mov( 1, eax );
			exit mca;
			
			
		// As above, but with reversed operands:
		
		Int8Uns8:
			mov( rData, eax );
			if( (type byte [eax]) >= $80 ) then

				mov( tInt16, lpt );
				mov( &int16_ste, lt );
				mov( tInt16, rpt );
				mov( &int16_ste, rt );
			
			else
			  
				mov( tInt8, rpt );
				mov( &int8_ste, rt );
			
			endif;
			mov( 1, eax );
			exit mca;


			
			
			
		// Int8<->Byte conversions always produce INT8 results.
		
		Int8Byte:
		ByteInt8:
			mov( tInt8, rpt );
			mov( &int8_ste, rt );
			mov( tInt8, rpt );
			mov( &int8_ste, rt );
			mov( 1, eax );
			exit mca;
			
				
				

		// If one of the operands is signed and at least one
		// of the operands is 16 bits (but not UNS16), then convert
		// the values to int16:
		
		Uns8Int16:
		Int8Int16:
		Int16Int8:
		ByteInt16:
		Int16Byte:
		Int16Uns8: 
		Int16Word:
		Int8Word:
		WordInt8: 
		WordInt16: 
			mov( tInt16, rpt );
			mov( &int16_ste, rt );
			mov( tInt16, lpt );
			mov( &int16_ste, lt );
			mov( 1, eax );
			exit mca;
			
		
			
		// Similar to the above, but with an Int32 object rather than Int16:
			
		Int8DWord:
		Int8Int32:
		Int16DWord:
		Int16Int32:
		Int32Uns8:
		Int32Uns16:
		Int32Int8:
		Int32Int16:
		Int32Byte:
		Int32Word:
		Int32DWord:
		Uns8Int32: 
		Uns16Int32:
		ByteInt32:
		WordInt32: 
		DWordInt8:
		DWordInt16:
		DWordInt32:
			mov( tInt32, rpt );
			mov( &int32_ste, rt );
			mov( tInt32, lpt );
			mov( &int32_ste, lt );
			mov( 1, eax );
			exit mca;
			
			
			
		// Similar to the above, but with an INT64 value
		// rather than Int32 or Int16:
		
		Uns8Int64: 
		Uns16Int64:
		Uns32Int64:
		Int64Uns8:
		Int64Uns16:
		Int64Uns32:
		Int8Int64:
		Int8QWord:
		Int16Int64:
		Int16QWord:
		Int32Int64:
		Int32QWord:
		Int64Int8:
		Int64Int16:
		Int64Int32:
		Int64Byte:
		Int64Word:
		Int64DWord:
		Int64QWord:
		ByteInt64: 
		WordInt64:
		DWordInt64:
		QWordInt8:
		QWordInt16:
		QWordInt32:
		QWordInt64: 
		 	mov( tInt64, lpt );
			mov( &int64_ste, lt );
		 	mov( tInt64, rpt );
			mov( &int64_ste, rt );
			mov( 1, eax );
			exit mca;
		
		
		// One type is unsigned and 64 bits or less, the other
		// is tbyte. Convert to a tByte object:
		
		Uns8TByte:
		TByteUns8:
		Uns16TByte:
		TByteUns16:
		Uns32TByte:
		TByteUns32:
		Uns64TByte:
		TByteUns64:
		ByteTByte:
		TByteByte:
		WordTByte:
		TByteWord:
		DWordTByte:
		TByteDWord:
		QWordTByte:
		TByteQWord:		
		 	mov( tTByte, lpt );
			mov( &tbyte_ste, lt );
		 	mov( tTByte, rpt );
			mov( &tbyte_ste, rt );
			mov( 1, eax );
			exit mca;
		
		
		
		// One type is signed and 64 bits or less, the other
		// is tbyte. Convert to an int128 object:
		
		Int8TByte:
		TByteInt8:
		Int16TByte:
		TByteInt16:
		Int32TByte:
		TByteInt32:
		Int64TByte:
		TByteInt64:
		 	mov( tInt128, lpt );
			mov( &int128_ste, lt );
		 	mov( tInt128, rpt );
			mov( &int128_ste, rt );
			mov( 1, eax );
			exit mca;
		
		
		
				
		
		// Almost like the above, except that if the uns16
		// value is greater than $8000 we have to create an
		// int32 value to hold the result.	
				
		Int8Uns16:
			mov( rData, eax );
			if( (type byte [eax+1]) >= $80 ) then

				mov( tInt32, lpt );
				mov( &int32_ste, lt );
				mov( tInt32, rpt );
				mov( &int32_ste, rt );
			
			else
			  
				mov( tInt16, lpt );
				mov( &int16_ste, lt );
				mov( tInt16, rpt );
				mov( &int16_ste, rt );
			
			endif;
			mov( 1, eax );
			exit mca;
			
			
		// As above, but with reversed operands:
		
		Uns16Int8:
			mov( lData, eax );
			if( (type byte [eax+1]) >= $80 ) then

				mov( tInt32, lpt );
				mov( &int32_ste, lt );
				mov( tInt32, rpt );
				mov( &int32_ste, rt );
			
			else
			  
				mov( tInt16, lpt );
				mov( &int16_ste, lt );
				mov( tInt16, rpt );
				mov( &int16_ste, rt );
			
			endif;
			mov( 1, eax );
			exit mca;
			
				

				
			
		// If the right operand is uns32 and the left operand
		// is signed, we will produce an int32 or int64 result
		// based on whether the H.O. bit of the Uns32 value is
		// set:
			
		Int8Uns32:
		Int16Uns32:
		Int32Uns32:
			mov( rData, eax );
			if( (type byte [eax+3]) >= $80 ) then

				mov( tInt64, lpt );
				mov( &int64_ste, lt );
				mov( tInt64, rpt );
				mov( &int64_ste, rt );
			
			else
			  
				mov( tInt32, lpt );
				mov( &int32_ste, lt );
				mov( tInt32, rpt );
				mov( &int32_ste, rt );
			
			endif;
			mov( 1, eax );
			exit mca;
			
		// As above, but the operands are reversed:
		
		Uns32Int8:
		Uns32Int16: 
		Uns32Int32:
			mov( lData, eax );
			if( (type byte [eax+3]) >= $80 ) then

				mov( tInt64, lpt );
				mov( &int64_ste, lt );
				mov( tInt64, rpt );
				mov( &int64_ste, rt );
			
			else
			  
				mov( tInt32, lpt );
				mov( &int32_ste, lt );
				mov( tInt32, rpt );
				mov( &int32_ste, rt );
			
			endif;
			mov( 1, eax );
			exit mca;
					
			
			
		// Like above, but with a 64-bit unsigned value rather than
		// 32-bits.	
				
		Int8Uns64:
		Int16Uns64:
		Int32Uns64:
		Int64Uns64:
			mov( rData, eax );
			if( (type byte [eax+7]) >= $80 ) then

				mov( tInt128, lpt );
				mov( &int128_ste, lt );
				mov( tInt128, rpt );
				mov( &int128_ste, rt );
			
			else
			  
				mov( tInt64, lpt );
				mov( &int64_ste, lt );
				mov( tInt64, rpt );
				mov( &int64_ste, rt );
			
			endif;
			mov( 1, eax );
			exit mca;
				
				
		// As above, with reversed operands:
			
		Uns64Int8:
		Uns64Int16: 
		Uns64Int32: 
		Uns64Int64:
			mov( lData, eax );
			if( (type byte [eax+7]) >= $80 ) then

				mov( tInt128, lpt );
				mov( &int128_ste, lt );
				mov( tInt128, rpt );
				mov( &int128_ste, rt );
			
			else
			  
				mov( tInt64, lpt );
				mov( &int64_ste, lt );
				mov( tInt64, rpt );
				mov( &int64_ste, rt );
			
			endif;
			mov( 1, eax );
			exit mca;

				
	
								
		
		// Left operand is Uns16, right operand is Int16.
		// If the unsigned operand is less than $8000, make
		// 'em both Int16 values, else make them both Int32 values.
		
			
				
		Uns16Int16:
			mov( lData, eax );
			if( (type byte [eax+1]) >= $80 ) then

				mov( tInt32, lpt );
				mov( &int32_ste, lt );
				mov( tInt32, rpt );
				mov( &int32_ste, rt );
			
			else
			  
				mov( tInt16, lpt );
				mov( &int16_ste, lt );
			
			endif;
			mov( 1, eax );
			exit mca;
			
			
		// As above, but with reversed operands:
			
		Int16Uns16:
			mov( rData, eax );
			if( (type byte [eax+1]) >= $80 ) then

				mov( tInt32, lpt );
				mov( &int32_ste, lt );
				mov( tInt32, rpt );
				mov( &int32_ste, rt );
			
			else
			  
				mov( tInt16, rpt );
				mov( &int16_ste, rt );
			
			endif;
			mov( 1, eax );
			exit mca;
			
				
			
				
								
		
		// One operand is 64 bits, both operands are unsigned.  Convert
		// both of them to Uns64:
		
		Uns64Uns8:
		Uns64Byte:  
		Uns64Word:
		Uns64Uns16:  
		Uns64DWord:
		Uns64Uns32:
		QWordUns8:
		QWordUns16:
		QWordUns32:  
		Uns8Uns64: 
		Uns16Uns64:
		Uns32Uns64: 
		Uns8QWord: 
		Uns16QWord:
		Uns32QWord:
		Uns64QWord:
		ByteUns64:
		WordUns64: 
		DWordUns64: 
		QWordUns64: 
			mov( tUns64, lpt );
			mov( &uns64_ste, lt );
			mov( tUns64, rpt );
			mov( &uns64_ste, rt );
			mov( 1, eax );
			exit mca;
			
				
				
	
			
				
	
								
		
		// One operand is 128 bits, both are unsigned.  Convert them
		// to Uns128:
		
		Uns8Uns128:
		Uns16Uns128:
		Uns32Uns128:
		Uns64Uns128: 
		Uns128Uns8:
		Uns128Uns16:  
		Uns128Uns32:  
		Uns128Uns64:  
		Uns128Byte:  
		Uns128Word:
		Uns128DWord:
		Uns128QWord:
		Uns128TByte:
		LWordUns8:
		LWordUns16:
		LWordUns32:
		LWordUns64:
		LWordUns128:
		Uns8LWord: 
		Uns16LWord:
		Uns32LWord:
		Uns64LWord:
		ByteUns128:
		WordUns128:
		DWordUns128:
		QWordUns128:
		TByteUns128: 
			mov( tUns128, lpt );
			mov( &uns128_ste, lt );
			mov( tUns128, rpt );
			mov( &uns128_ste, rt );
			mov( 1, eax );
			exit mca;
			
				
			
		// One operand is 128 bits, at least one is signed.  Convert them
		// to Int128:
				
		Uns8Int128:	
		Uns16Int128:
		Uns32Int128:
		Uns64Int128: 
		Uns128Int8:
		Uns128Int16: 
		Uns128Int32: 
		Uns128Int64: 
		Uns128Int128:
		ByteInt128:
		WordInt128:
		DWordInt128:
		QWordInt128:
		TByteInt128:
		LWordInt8:
		LWordInt16:
		LWordInt32:
		LWordInt64:
		LWordInt128: 
		Int8Uns128:
		Int8Int128:
		Int8LWord:
		Int16Int128:
		Int16Uns128:
		Int16LWord:
		Int32Int128:
		Int32Uns128:
		Int32LWord:
		Int64Int128:
		Int64Uns128:
		Int64LWord:
		Int128Uns8:
		Int128Uns16:
		Int128Uns32:
		Int128Uns64:
		Int128Uns128:
		Int128Byte:
		Int128Word:
		Int128DWord:
		Int128QWord:
		Int128TByte:
		Int128LWord:
		Int128Int8:
		Int128Int16:
		Int128Int32:
		Int128Int64:
			mov( tInt128, lpt );
			mov( &int128_ste, lt );
			mov( tInt128, rpt );
			mov( &int128_ste, rt );
			mov( 1, eax );
			exit mca;
			
			
			
		// Hex conversions.  One operand is byte, one is word,
		// upgrade both to word:

		ByteWord:
		WordByte: 
			mov( tWord, lpt );
			mov( &word_ste, lt );
			mov( tWord, rpt );
			mov( &word_ste, rt );
			mov( 1, eax );
			exit mca;
			
			

		// Hex conversions.  One operand is dword, the other one
		// is a hex type.  Convert them both to dword:

		ByteDWord:
		WordDWord:
		DWordByte:
		DWordWord: 
			mov( tDWord, lpt );
			mov( &dword_ste, lt );
			mov( tDWord, rpt );
			mov( &dword_ste, rt );
			mov( 1, eax );
			exit mca;
			
			

		// Hex conversions.  One operand is qword, the other one
		// is a hex type.  Convert them both to qword:

		ByteQWord:
		WordQWord:
		DWordQWord:
		QWordByte:
		QWordWord: 
		QWordDWord:
			mov( tQWord, lpt );
			mov( &qword_ste, lt );
			mov( tQWord, rpt );
			mov( &qword_ste, rt );
			mov( 1, eax );
			exit mca;
			
			

		// Hex conversions.  One operand is lword, the other one
		// is a hex type.  Convert them both to lword:

		ByteLWord:
		WordLWord:
		DWordLWord:
		QWordLWord:
		TByteLWord:
		LWordByte:
		LWordWord: 
		LWordDWord:
		LWordQWord:
		LWordTByte:
			mov( tLWord, lpt );
			mov( &lword_ste, lt );
			mov( tLWord, rpt );
			mov( &lword_ste, rt );
			mov( 1, eax );
			exit mca;
			
			

			
				

			
			
			
				
	
		// Come here if the types are trivially compatible:
		
		s:
			mov( 1, eax );
			exit mca;
			
		// Drop down here if the types are incompatible:
		
		x:
			xor( eax, eax );  // Return false as function result.			
		
			
	end mca;
	pop( esi );
	pop( edi );
	pop( edx );
	pop( ecx );
	pop( ebx ); 	


end MakeCompAsm;



////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
///////////////////////                           //////////////////////
/////////////////////// Integer  Support Routines //////////////////////
///////////////////////                           //////////////////////
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////


// UnsLT, UnsLE, UnsGT, UnsGE, IntLT, IntLE, IntGT, IntGE-
//
//	These procedures perform the specified 128-bit comparison
// and return true or false in EAX.
//
//	The HLA compiler uses these functions for all UnsXX,
// HexXX (byte,word,etc.), and IntXX comparisons.
// This means that the compiler *must* maintain 128-bit
// values throughout all computations, even for smaller
// results (i.e., HLA must use zero or sign extension so
// the number is valid through 128 bits).

procedure UnsLT( var left:var; var right:var ); 
begin UnsLT;

	push( esi );
	push( edi );
	push( ebx );
	
	mov( left, esi );
	mov( right, edi );
	
	// Standard 128-bit unsigned comparison.
	// Compare from the H.O. dword on down.
	
	xor( eax, eax );
	mov( [esi+12], ebx );
	cmp( ebx, [edi+12] );
	setb( al );
	if( @z ) then
	
		mov( [esi+8], ebx );
		cmp( ebx, [edi+8] );
		setb( al );
	
		if( @z ) then
		
			mov( [esi+4], ebx );
			cmp( ebx, [edi+4] );
			setb( al );
	
			if( @z ) then
			
				mov( [esi], ebx );
				cmp( ebx, [edi] );
				setb( al );
				
			endif;
			
		endif;
		
	endif;
	
	pop( ebx );
	pop( edi );
	pop( esi );
	
end UnsLT;
	
	


procedure UnsLE( var left:var; var right:var ); 
begin UnsLE;

	push( esi );
	push( edi );
	push( ebx );
	
	mov( left, esi );
	mov( right, edi );
	
	// Standard 128-bit unsigned comparison.
	// Compare from the H.O. dword on down.
	
	xor( eax, eax );
	mov( [esi+12], ebx );
	cmp( ebx, [edi+12] );
	setb( al );
	if( @z ) then
	
		mov( [esi+8], ebx );
		cmp( ebx, [edi+8] );
		setb( al );
	
		if( @z ) then
		
			mov( [esi+4], ebx );
			cmp( ebx, [edi+4] );
			setb( al );
	
			if( @z ) then
			
				mov( [esi], ebx );
				cmp( ebx, [edi] );
				setbe( al );
				
			endif;
			
		endif;
		
	endif;
	
	pop( ebx );
	pop( edi );
	pop( esi );
	
end UnsLE;
	
	


procedure UnsGT( var left:var; var right:var ); 
begin UnsGT;

	push( esi );
	push( edi );
	push( ebx );
	
	mov( left, esi );
	mov( right, edi );
	
	// Standard 128-bit unsigned comparison.
	// Compare from the H.O. dword on down.
	
	xor( eax, eax );
	mov( [esi+12], ebx );
	cmp( ebx, [edi+12] );
	seta( al );
	if( @z ) then
	
		mov( [esi+8], ebx );
		cmp( ebx, [edi+8] );
		seta( al );
	
		if( @z ) then
		
			mov( [esi+4], ebx );
			cmp( ebx, [edi+4] );
			seta( al );
	
			if( @z ) then
			
				mov( [esi], ebx );
				cmp( ebx, [edi] );
				seta( al );
				
			endif;
			
		endif;
		
	endif;
	
	pop( ebx );
	pop( edi );
	pop( esi );
	
end UnsGT;
	
	


procedure UnsGE( var left:var; var right:var ); 
begin UnsGE;

	push( esi );
	push( edi );
	push( ebx );
	
	mov( left, esi );
	mov( right, edi );
	
	// Standard 128-bit unsigned comparison.
	// Compare from the H.O. dword on down.
	
	xor( eax, eax );
	mov( [esi+12], ebx );
	cmp( ebx, [edi+12] );
	seta( al );
	if( @z ) then
	
		mov( [esi+8], ebx );
		cmp( ebx, [edi+8] );
		seta( al );
	
		if( @z ) then
		
			mov( [esi+4], ebx );
			cmp( ebx, [edi+4] );
			seta( al );
	
			if( @z ) then
			
				mov( [esi], ebx );
				cmp( ebx, [edi] );
				setae( al );
				
			endif;
			
		endif;
		
	endif;
	
	pop( ebx );
	pop( edi );
	pop( esi );
	
end UnsGE;
	





procedure IntLT( var left:var; var right:var ); 
begin IntLT;

	push( esi );
	push( edi );
	push( ebx );
	
	mov( left, esi );
	mov( right, edi );
	
	// Standard 128-bit signed comparison.
	// Compare from the H.O. dword on down.
	
	xor( eax, eax );
	mov( [esi+12], ebx );
	cmp( ebx, [edi+12] );
	setl( al );
	if( @z ) then
	
		mov( [esi+8], ebx );
		cmp( ebx, [edi+8] );
		setl( al );
	
		if( @z ) then
		
			mov( [esi+4], ebx );
			cmp( ebx, [edi+4] );
			setl( al );
	
			if( @z ) then
			
				mov( [esi], ebx );
				cmp( ebx, [edi] );
				setl( al );
				
			endif;
			
		endif;
		
	endif;
	
	pop( ebx );
	pop( edi );
	pop( esi );
	
end IntLT;
	
	


procedure IntLE( var left:var; var right:var ); 
begin IntLE;

	push( esi );
	push( edi );
	push( ebx );
	
	mov( left, esi );
	mov( right, edi );
	
	// Standard 128-bit signed comparison.
	// Compare from the H.O. dword on down.
	
	xor( eax, eax );
	mov( [esi+12], ebx );
	cmp( ebx, [edi+12] );
	setl( al );
	if( @z ) then
	
		mov( [esi+8], ebx );
		cmp( ebx, [edi+8] );
		setl( al );
	
		if( @z ) then
		
			mov( [esi+4], ebx );
			cmp( ebx, [edi+4] );
			setl( al );
	
			if( @z ) then
			
				mov( [esi], ebx );
				cmp( ebx, [edi] );
				setle( al );
				
			endif;
			
		endif;
		
	endif;
	
	pop( ebx );
	pop( edi );
	pop( esi );
	
end IntLE;
	
	


procedure IntGT( var left:var; var right:var ); 
begin IntGT;

	push( esi );
	push( edi );
	push( ebx );
	
	mov( left, esi );
	mov( right, edi );
	
	// Standard 128-bit signed comparison.
	// Compare from the H.O. dword on down.
	
	xor( eax, eax );
	mov( [esi+12], ebx );
	cmp( ebx, [edi+12] );
	setg( al );
	if( @z ) then
	
		mov( [esi+8], ebx );
		cmp( ebx, [edi+8] );
		setg( al );
	
		if( @z ) then
		
			mov( [esi+4], ebx );
			cmp( ebx, [edi+4] );
			setg( al );
	
			if( @z ) then
			
				mov( [esi], ebx );
				cmp( ebx, [edi] );
				setg( al );
				
			endif;
			
		endif;
		
	endif;
	
	pop( ebx );
	pop( edi );
	pop( esi );
	
end IntGT;
	
	


procedure IntGE( var left:var; var right:var ); 
begin IntGE;

	push( esi );
	push( edi );
	push( ebx );
	
	mov( left, esi );
	mov( right, edi );
	
	// Standard 128-bit signed comparison.
	// Compare from the H.O. dword on down.
	
	xor( eax, eax );
	mov( [esi+12], ebx );
	cmp( ebx, [edi+12] );
	setg( al );
	if( @z ) then
	
		mov( [esi+8], ebx );
		cmp( ebx, [edi+8] );
		setg( al );
	
		if( @z ) then
		
			mov( [esi+4], ebx );
			cmp( ebx, [edi+4] );
			setg( al );
	
			if( @z ) then
			
				mov( [esi], ebx );
				cmp( ebx, [edi] );
				setge( al );
				
			endif;
			
		endif;
		
	endif;
	
	pop( ebx );
	pop( edi );
	pop( esi );
	
end IntGE;
	




// negval-	Computes dest = -src.

procedure negval
( 
	var dest	:var;
	var	src		:var;
		vpt		:pType;
	var	vpta	:pType;
		vt		:dword
);
const
	s:text := "[ebx]";
	d:text := "[ecx]";
	p:text := "(type byte [edi])";
	t:text := "(type dword [esi])";

begin negval;

	push( ebx );
	push( ecx );
	push( edx );
	push( edi );
	push( esi );
	
	mov( src, ebx );
	mov( dest, ecx );
	mov( vpta, edi );
	mov( vt, esi );
	
	
	// Set the result type (do this first because the
	// source and destination operands may be the same
	// and we need to check the source operand prior to
	// negation to determine certain result types).
	
	movzx( vpt, eax );
	switch( eax )
	
		case( tInt8 )

			mov( tInt8, p );
			mov( &int8_ste, t );

		
		case( _tByte )
		
			mov( _tByte, p );
			mov( &byte_ste, t );
		
		
		case( tInt16 )

			mov( tInt16, p );
			mov( &int16_ste, t );
		
		case( tWord )
		
			mov( tWord, p );
			mov( &word_ste, t );
		
		case( tInt32 )

			mov( tInt32, p );
			mov( &int32_ste, t );
		
		case( tDWord )
		
			mov( tDWord, p );
			mov( &dword_ste, t );
		
		case( tInt64 )

			mov( tInt64, p );
			mov( &int64_ste, t );
		
		case( tQWord )
		
			mov( tQWord, p );
			mov( &qword_ste, t );
		
		case( tTByte )
		
			mov( tTByte, p );
			mov( &tbyte_ste, t );
		
		case( tInt128 )

			mov( tInt128, p );
			mov( &int128_ste, t );
		
		case( tLWord )
		
			mov( tLWord, p );
			mov( &lword_ste, t );
		
			
		// The above cases do a full 128-bit negation and
		// leave the resulting type alone.	
		
		case( tUns8 )
		
			// If the H.O. bit was set, we need to extend the value
			// to 16 bits; otherwise we can leave it at eight bits.
			
			mov( tInt8, p );
			mov( &int8_ste, t );
			if( (type byte s) >= $80 ) then
			
				mov( tInt16, p );
				mov( &int16_ste, t );
				
			endif; 
				
			
		case( tUns16 )
		
			// If the H.O. bit was set, we need to extend the value
			// to 32 bits; otherwise we can leave it at 16 bits.
			
			mov( tInt16, p );
			mov( &int16_ste, t );
			if( (type byte s[1]) >= $80 ) then

				mov( tInt32, p );
				mov( &int32_ste, t );
				
			endif; 
				
			
		case( tUns32 )
		
			// If the H.O. bit is set, we need to extend the value
			// to 64 bits; otherwise we can leave it at 32 bits.

			mov( tInt32, p );
			mov( &int32_ste, t );
			if( (type byte s[3]) >= $80 ) then

				mov( tInt64, p );
				mov( &int64_ste, t );
				
			endif; 
				
			
		case( tUns64 )
		
			// If the H.O. bit is set, we need to extend the value
			// to 128 bits; otherwise we can leave it at 64 bits.
			
			mov( tInt64, p );
			mov( &int64_ste, t );
			if( (type byte s[7]) >= $80 ) then

				mov( tInt128, p );
				mov( &int128_ste, t );
				
			endif; 
				
			
		case( tUns128 )
		
			// Not much we can do for Uns128 values.  If it overflows,
			// it does so quietly.
			
			mov( tInt128, p );
			mov( &int128_ste, t );
				
				
			
		
		case( tReal32 )
		
			fld( (type real32 s ) );
			fchs();
			fstp( (type real32 d ) );
			mov( tReal32, p );
			mov( &real32_ste, t );
			
		case( tReal64 )
		
			fld( (type real64 s ) );
			fchs();
			fstp( (type real64 d ) );
			mov( tReal64, p );
			mov( &real64_ste, t );
			
		case( tReal80 )
		
			fld( (type real80 s ) );
			fchs();
			fstp( (type real80 d ) );
			mov( tReal80, p );
			mov( &real80_ste, t );
			
		
		case( tCset )
		
			mov( s, eax );
			not( eax );
			mov( eax, d );
			mov( s[4], eax );
			not( eax );
			mov( eax, d[4] );
			mov( s[8], eax );
			not( eax );
			mov( eax, d[8] );
			mov( s[12], eax );
			not( eax );
			mov( eax, d[12] );
			mov( tCset, p );
			mov( &cset_ste, t );
		
		default
		
			yyerror( "'-' operand must be numeric or cset value" );
			xor( eax, eax );
			mov( eax, d );
			mov( eax, d[4] );
			mov( eax, d[8] );
			mov( eax, d[12] );
			mov( tUns8, p );
			mov( &uns8_ste, t );
		
	endswitch;
	
	// Real and Cset negations were handled in the switch.
	// But the integer negations are taken care of down here
	// to eliminate a bunch of redundant code.
	//
	// Note that tReal32, tReal64, tReal80, and tCset are all
	// greater than tInt128 (the largest of the integer pTypes).
	
	if( vpt <= tInt128 ) then
	
		// Do a 128-bit negation:
		
		xor( eax, eax );
		sub( s, eax );
		mov( eax, d );
		mov( 0, eax );
		sbb( s[4], eax );
		mov( eax, d[4] );
		mov( 0, eax );
		sbb( s[8], eax );
		mov( eax, d[8] );
		mov( 0, eax );
		sbb( s[12], eax );
		mov( eax, d[12] );
		
		// Reduce the type of this object to it's smallest form:
		
		compactType( d, p, t );
		
	endif;
	
	
	pop( esi );
	pop( edi );
	pop( edx );
	pop( ecx );
	pop( ebx );
		
end negval;











// notval-	Computes dest = !src (bitwise).

procedure notval
( 
	var dest	:var;
	var	src		:var;
		vpt		:pType;
	var	vpta	:pType;
		vt		:dword
);
const
	s:text := "[ebx]";
	d:text := "[ecx]";
	p:text := "(type byte [edi])";
	t:text := "(type dword [esi])";

begin notval;

	push( ebx );
	push( ecx );
	push( edx );
	push( edi );
	push( esi );
	
	mov( src, ebx );
	mov( dest, ecx );
	mov( vpta, edi );
	mov( vt, esi );
	
	movzx( vpt, eax );
	switch( eax )
	
		case( tBoolean )
		
			movzx( (type byte s), eax );
			and( 1, al );
			xor( 1, al );
			mov( eax, d );
			mov( 0, (type dword d[4]) );
			mov( 0, (type dword d[8]) );
			mov( 0, (type dword d[12]));
			mov( tBoolean, p );
			mov( &boolean_ste, t ); 
			
		case( _tByte, tInt8 )

			// The H.O. bits (beyond bit #7) of a byte object
			// must all be zeros or ones.  Enforce that here
			// and then negate the full 128-bit value.
			//
			// Note that we can't use bit #7 as a sign extension
			// bit because it's quite possible that various
			// byte operations have cleared this bit even though
			// the H.O. bits are all set.  So we'll just test bits
			// 8..127.  If they're not all zero, we'll assume that
			// they're all ones. 
			
			mov( s, eax );
			mov( ah, al );
			or( s[4], eax );
			or( s[8], eax );
			or( s[12], eax );
			if( @nz ) then
			
				mov( -1, eax );
				
			endif;
			not( eax );			// Need to invert these bits.
			mov( eax, d[0] );
			mov( eax, d[4] );
			mov( eax, d[8] );
			mov( eax, d[12] );
			
			// Okay, invert the L.O. byte and we're done:
			
			mov( s, al );
			not( al );
			mov( al, d );
			
			mov( _tByte, p );
			mov( &byte_ste, t ); 
			
		case( tUns8 )

			// We'll tacitly assume that the H.O. bits of
			// an Uns8 object are all zero.  However, when
			// we invert all the bits, we wind up with
			// a lot of set bits in the H.O. bit positions.
			// Therefore, we cannot leave the type Uns8.
			// Inverting just the L.O. byte is just as bad
			// because future calculations may expect the
			// upper bits to be non-zero after inversion.
			// So we'll just convert the type to Byte (which
			// allows H.O. set bits) and leave it at that.
			
			mov( (type byte s), al );
			not( al );
			or( $FFFF_FF00, eax );
			mov( eax, d );
			mov( ah, al );
			mov( eax, d[4] );
			mov( eax, d[8] );
			mov( eax, d[12] );
			
			mov( _tByte, p );
			mov( &byte_ste, t ); 
			
			
			
			
		case( tInt16, tWord )
					 
			// See case( tInt8, _tByte ) for comments.
			// This case is an obvious extension of that
			// code to 16 bits.
			
			movsx( (type word s[2]), eax );
			or( s[4], eax );
			or( s[8], eax );
			or( s[12], eax );
			if( @nz ) then
			
				or( -1, eax );	// Force all bits to 1s
				
			endif;
			not( eax );			// Need to invert these bits.
			mov( eax, d[0] );
			mov( eax, d[4] );
			mov( eax, d[8] );
			mov( eax, d[12] );
			
			// Okay, invert the L.O. word and we're done:
			
			mov( s, ax );
			not( ax );
			mov( ax, d );
			
			mov( tWord, p );
			mov( &word_ste, t );
		
			// Reduce the type of this object to it's smallest form:
			
			compactType( d, p, t );
			 
			
		case( tUns16 ) 
			
			// see case( tUns8) for comments.  Obvious
			// extension of that code to 16 bits.
			
			mov( s, ax );
			not( ax );
			or( $FFFF_0000, eax );
			mov( eax, d );
			or( -1, eax );
			mov( eax, d[4] );
			mov( eax, d[8] );
			mov( eax, d[12] );
			
			mov( tWord, p );
			mov( &word_ste, t ); 

			// Reduce the type of this object to it's smallest form:
			
			compactType( d, p, t );
			
			
		case( tUns32 )
			
			// see case( tUns8) for comments.  Obvious
			// extension of that code to 32 bits.
			
			mov( s, eax );
			not( eax );
			mov( eax, d );
			or( -1, eax );
			mov( eax, d[4] );
			mov( eax, d[8] );
			mov( eax, d[12] );
			
			mov( tDWord, p );
			mov( &dword_ste, t ); 

			// Reduce the type of this object to it's smallest form:
			
			compactType( d, p, t );
		
		case( tInt32, tDWord )
					 
			// See case( tInt8, _tByte ) for comments.
			// This case is an obvious extension of that
			// code to 32 bits.
			
			mov( s[4], eax );
			or( s[8], eax );
			or( s[12], eax );
			if( @nz ) then
			
				or( -1, eax );
				
			endif;
			not( eax );			// Need to invert these bits.
			mov( eax, d[4] );
			mov( eax, d[8] );
			mov( eax, d[12] );
			
			// Okay, invert the L.O. word and we're done:
			
			mov( s, eax );
			not( eax );
			mov( eax, d );
			
			mov( tDWord, p );
			mov( &dword_ste, t );

			// Reduce the type of this object to it's smallest form:
			
			compactType( d, p, t );
			
			
		case( tUns64 )
			
			// see case( tUns8) for comments.  Obvious
			// extension of that code to 64 bits.
			
			mov( s, eax );
			not( eax );
			mov( eax, d );
			mov( s[4], eax );
			not( eax );
			mov( eax, d[4] );
			or( -1, eax );
			mov( eax, d[8] );
			mov( eax, d[12] );
			
			mov( tQWord, p );
			mov( &qword_ste, t ); 

			// Reduce the type of this object to it's smallest form:
			
			compactType( d, p, t );
		
		
		case( tInt64, tQWord )
					 
			// See case( tInt8, _tByte ) for comments.
			// This case is an obvious extension of that
			// code to 64 bits.
			
			mov( s[8], eax );
			or( s[12], eax );
			if( @nz ) then
			
				mov( -1, eax );
				
			endif;
			not( eax );			// Need to invert these bits.
			mov( eax, d[8] );
			mov( eax, d[12] );
			
			// Okay, invert the L.O. word and we're done:
			
			mov( s, eax );
			not( eax );
			mov( eax, d );
			
			mov( s[4], eax );
			not( eax );
			mov( eax, d[4] );
			
			mov( tQWord, p );
			mov( &qword_ste, t );

			// Reduce the type of this object to it's smallest form:
			
			compactType( d, p, t );
		
		
		case( tTByte )
					 
			// See case( tInt8, _tByte ) for comments.
			// This case is an obvious extension of that
			// code to 80 bits.
			
			movzx( (type word s[10]), eax );
			or( s[12], eax );
			if( @nz ) then
			
				or( -1, eax );
				
			endif;
			not( eax );			// Need to invert these bits.
			mov( ax, d[10] );
			mov( eax, d[12] );
			
			// Okay, invert the L.O. word and we're done:
			
			mov( s, eax );
			not( eax );
			mov( eax, d );
			
			mov( s[4], eax );
			not( eax );
			mov( eax, d[4] );
			
			mov( (type word s[8]), ax );
			not( ax );
			mov( ax, (type word d[4]) );
			
			mov( tTByte, p );
			mov( &tbyte_ste, t );

			// Reduce the type of this object to it's smallest form:
			
			compactType( d, p, t );
		
		
	
			
		case( tInt128, tUns128, tLWord )
		
			// No semantic issues here.  Just invert all the bits.
			
			mov( s, eax );
			not( eax );
			mov( eax, d );
			mov( s[4], eax );
			not( eax );
			mov( eax, d[4] );
			mov( s[8], eax );
			not( eax );
			mov( eax, d[8] );
			mov( s[12], eax );
			not( eax );
			mov( eax, d[12] );
			
			mov( tLWord, p );
			mov( &lword_ste, t ); 

			// Reduce the type of this object to it's smallest form:
			
			compactType( d, p, t );
		
		default
		
			yyerror( "'!' operand must be boolean or integer value" );
			xor( eax, eax );
			mov( eax, d );
			mov( eax, d[4] );
			mov( eax, d[8] );
			mov( eax, d[12] );
			mov( tUns8, p );
			mov( &uns8_ste, t );
		
	endswitch;
	
	pop( esi );
	pop( edi );
	pop( edx );
	pop( ecx );
	pop( ebx );
		
end notval;







	


// addval-	Computes dest := dest + src.
//			Note: The C code is responsible for handling
//			characters and strings.

procedure addval
( 
	var dest	:var;
	var	src		:var;
	var	vpt		:pType;
	var	typ		:var
);
begin addval;

	push( esi );
	push( edi );
	push( ecx );
	push( ebx );
	
	mov( dest, edi );
	mov( src, esi );
	mov( vpt, ebx );
	mov( typ, ecx );
	
	movzx( (type byte [ebx]), eax );
	switch( eax )
	
		case( tUns8 )
		
			mov( [esi], al );
			add( al, [edi] );
			if( @nc ) then
			
				mov( 0, (type byte [edi+1]));
				
			else
			
				mov( 1, (type byte [edi+1]));
				mov( tUns16, (type byte [ebx]) );
				mov( &uns16_ste, (type dword [ecx]) );
				
			endif;
			xor( eax, eax );
			mov( ax, [edi+2] );
			mov( eax, [edi+4] );
			mov( eax, [edi+8] );
			mov( eax, [edi+12] );
		
	
		case( tInt8 )
		
			// Note that we always maintain signed values
			// as 128-bit objects.  So we have to do a full
			// 128-bit add here:
			
			mov( [esi], eax );
			add( eax, [edi] );
			mov( [esi+4], eax );
			adc( eax, [edi+4] );
			mov( [esi+8], eax );
			adc( eax, [edi+8] );
			mov( [esi+12], eax );
			adc( eax, [edi+12] );
			
			// If there was overflow/underflow, then
			// upgrade the type to Int16:
			
			movsx( (type byte [edi]), eax );
			if( ah <> [edi+1] ) then
			
				mov( tInt16, (type byte [ebx]) );
				mov( &int16_ste, (type dword [ecx]) );
				
			endif;
		
	
	
		case( _tByte )
		
			mov( [esi], al );
			add( al, [edi] );
			if( @nc ) then
			
				mov( 0, (type byte [edi+1]));
				
			else
			
				mov( 1, (type byte [edi+1]));
				mov( tWord, (type byte [ebx]) );
				mov( &word_ste, (type dword [ecx]) );
				
			endif;
			xor( eax, eax );
			mov( ax, [edi+2] );
			mov( eax, [edi+4] );
			mov( eax, [edi+8] );
			mov( eax, [edi+12] );
		
	
		case( tUns16 )
		
			mov( [esi], ax );
			add( ax, [edi] );
			if( @nc ) then
			
				mov( 0, (type word [edi+2]));
				
				// If the result fits into eight bits, shrink
				// the size down:
				
				if( (type byte [edi+1]) = 0 ) then
				
					mov( tUns8, (type byte [ebx]));
					mov( &uns8_ste, (type dword [ecx]));
					
				endif;
								
			else
			
				mov( 1, (type word [edi+2]));
				mov( tUns32, (type byte [ebx]));
				mov( &uns32_ste, (type dword [ecx]));
				
			endif;
			xor( eax, eax );
			mov( eax, [edi+4] );
			mov( eax, [edi+8] );
			mov( eax, [edi+12] );
		
	
		case( tInt16 )
		
			// Note that we always maintain signed values
			// as 128-bit objects.  So we have to do a full
			// 128-bit add here:
			
			mov( [esi], eax );
			add( eax, [edi] );
			mov( [esi+4], eax );
			adc( eax, [edi+4] );
			mov( [esi+8], eax );
			adc( eax, [edi+8] );
			mov( [esi+12], eax );
			adc( eax, [edi+12] );
			
			// Reduce the type of this object to it's smallest form:
			
			mov( tInt32, (type byte [ebx]) );
			mov( &int32_ste, (type dword [ecx]) );
			compactType( [edi], [ebx], [ecx] );

		
	
		case( tWord )
		
			mov( [esi], ax );
			add( ax, [edi] );
			if( @nc ) then
			
				mov( 0, (type word [edi+2]));
				
				// If the result fits into eight bits, shrink
				// the size down:
				
				if( (type byte [edi+1]) = 0 ) then
				
					mov( _tByte, (type byte [ebx]));
					mov( &byte_ste, (type dword [ecx]));
					
				endif;
				
			else
			
				mov( 1, (type word [edi+2]));
				mov( tDWord, (type byte [ebx]));
				mov( &dword_ste, (type dword [ecx]));
				
			endif;
			xor( eax, eax );
			mov( eax, [edi+4] );
			mov( eax, [edi+8] );
			mov( eax, [edi+12] );
		
	
		case( tUns32 )
		
			mov( [esi], eax );
			add( eax, [edi] );
			if( @nc ) then
			
				mov( 0, (type dword [edi+4]));
				
			else
			
				mov( 1, (type dword [edi+4]));
				
			endif;
			xor( eax, eax );
			mov( eax, [edi+8] );
			mov( eax, [edi+12] );
			
			// Reduce the type of this object to it's smallest form:
			
			mov( tUns64, (type byte [ebx]) );
			mov( &uns64_ste, (type dword [ecx]) );
			compactType( [edi], [ebx], [ecx] );
		
	
		case( tInt32 )
		
			// Note that we always maintain signed values
			// as 128-bit objects.  So we have to do a full
			// 128-bit add here:
			
			mov( [esi], eax );
			add( eax, [edi] );
			mov( [esi+4], eax );
			adc( eax, [edi+4] );
			mov( [esi+8], eax );
			adc( eax, [edi+8] );
			mov( [esi+12], eax );
			adc( eax, [edi+12] );
			
			// Reduce the type of this object to it's smallest form:
			
			mov( tInt64, (type byte [ebx]) );
			mov( &int64_ste, (type dword [ecx]) );
			compactType( [edi], [ebx], [ecx] );

	
		case( tDWord )
		
			mov( [esi], eax );
			add( eax, [edi] );
			if( @nc ) then
			
				mov( 0, (type dword [edi+4]));
				
				
			else
			
				mov( 1, (type dword [edi+4]));
				
			endif;
			xor( eax, eax );
			mov( eax, [edi+8] );
			mov( eax, [edi+12] );
			
			// Reduce the type of this object to it's smallest form:
			
			mov( tQWord, (type byte [ebx]) );
			mov( &qword_ste, (type dword [ecx]) );
			compactType( [edi], [ebx], [ecx] );
			
			
		
		
	
		case( tUns64 )
		
			mov( [esi], eax );
			add( eax, [edi] );
			mov( [esi+4], eax );
			adc( eax, [edi+4] );
			if( @nc ) then
			
				mov( 0, (type dword [edi+8]));
				
			else
			
				mov( 1, (type dword [edi+8]));
				
			endif;
			mov( 0, (type dword [edi+12]));
			
			// Reduce the type of this object to it's smallest form:
			
			mov( tUns128, (type byte [ebx]) );
			mov( &uns128_ste, (type dword [ecx]) );
			compactType( [edi], [ebx], [ecx] );
		
	
		case( tInt64 )
		
			// Note that we always maintain signed values
			// as 128-bit objects.  So we have to do a full
			// 128-bit add here:
			
			mov( [esi], eax );
			add( eax, [edi] );
			mov( [esi+4], eax );
			adc( eax, [edi+4] );
			mov( [esi+8], eax );
			adc( eax, [edi+8] );
			mov( [esi+12], eax );
			adc( eax, [edi+12] );
			
			
			// Reduce the type of this object to it's smallest form:
			
			mov( tInt128, (type byte [ebx]) );
			mov( &int128_ste, (type dword [ecx]) );
			compactType( [edi], [ebx], [ecx] );
		
		
	
		case( tQWord )
		
			mov( [esi], eax );
			add( eax, [edi] );
			mov( [esi+4], eax );
			adc( eax, [edi+4]);
			if( @nc ) then
			
				mov( 0, (type dword [edi+8]));
				
			else
			
				mov( 1, (type dword [edi+8]));
				
			endif;
			mov( 0, (type dword [edi+12]));
			
			// Reduce the type of this object to it's smallest form:
			
			mov( tLWord, (type byte [ebx]) );
			mov( &lword_ste, (type dword [ecx]) );
			compactType( [edi], [ebx], [ecx] );
		
		
	
		case( tTByte )
		
			mov( [esi], eax );
			add( eax, [edi] );
			mov( [esi+4], eax );
			adc( eax, [edi+4]);
			mov( [esi+8], ax );
			adc( ax, [esi+8] );
			if( @nc ) then
			
				mov( 0, (type word [edi+10]));
				
			else
			
				mov( 1, (type word [edi+10]));
				
			endif;
			mov( 0, (type dword [edi+12]));
			
			// Reduce the type of this object to it's smallest form:
			
			mov( tLWord, (type byte [ebx]) );
			mov( &lword_ste, (type dword [ecx]) );
			compactType( [edi], [ebx], [ecx] );
			
			
		
		case( tUns128 )
		
			// No way to deal with overflow, so ignore it:
			
			mov( [esi], eax );
			add( eax, [edi] );
			mov( [esi+4], eax );
			adc( eax, [edi+4] );
			mov( [esi+8], eax );
			adc( eax, [edi+8] );
			mov( [esi+12], eax );
			adc( eax, [edi+12] );
				
			
			// Reduce the type of this object to it's smallest form:
			
			mov( tUns128, (type byte [ebx]) );
			mov( &uns128_ste, (type dword [ecx]) );
			compactType( [edi], [ebx], [ecx] );
			
			
			
		case( tLWord )
		
			// No way to deal with overflow, so ignore it:
			
			mov( [esi], eax );
			add( eax, [edi] );
			mov( [esi+4], eax );
			adc( eax, [edi+4] );
			mov( [esi+8], eax );
			adc( eax, [edi+8] );
			mov( [esi+12], eax );
			adc( eax, [edi+12] );
				
			
			// Reduce the type of this object to it's smallest form:
			
			mov( tLWord, (type byte [ebx]) );
			mov( &lword_ste, (type dword [ecx]) );
			compactType( [edi], [ebx], [ecx] );
			
			
		case( tInt128 )
		
			// No way to deal with overflow, so ignore it:
			
			mov( [esi], eax );
			add( eax, [edi] );
			mov( [esi+4], eax );
			adc( eax, [edi+4] );
			mov( [esi+8], eax );
			adc( eax, [edi+8] );
			mov( [esi+12], eax );
			adc( eax, [edi+12] );
			
			// Reduce the type of this object to it's smallest form:
			
			mov( tInt128, (type byte [ebx]) );
			mov( &int128_ste, (type dword [ecx]) );
			compactType( [edi], [ebx], [ecx] );
				
			
			
			
		case( tReal32 )
		
			fld( (type real32 [esi]) );
			fld( (type real32 [edi]) );
			faddp();
			fstp( (type real80 [edi]) );
			mov( tReal80, (type byte [ebx]) );
			mov( &real80_ste, (type dword [ecx]) );
			xor( eax, eax );
			mov( eax, [edi+4] );
			mov( eax, [edi+8] );
			mov( eax, [edi+12] );
			
		case( tReal64 )
		
			fld( (type real64 [esi]) );
			fld( (type real64 [edi]) );
			faddp();
			fstp( (type real80 [edi]) );
			mov( tReal80, (type byte [ebx]) );
			mov( &real80_ste, (type dword [ecx]) );
			xor( eax, eax );
			mov( eax, [edi+8] );
			mov( eax, [edi+12] );
			
		case( tReal80 )
		
			fld( (type real80 [esi]) );
			fld( (type real80 [edi]) );
			faddp();
			fstp( (type real80 [edi]) );
			xor( eax, eax );
			mov( ax, [edi+10] );
			mov( eax, [edi+12] );
			
		case( tCset )
		
			mov( [esi], eax );
			or( eax, [edi] );
			mov( [esi+4], eax );
			or( eax, [edi+4] );
			mov( [esi+8], eax );
			or( eax, [edi+8] );
			mov( [esi+12], eax );
			or( eax, [edi+12] );
			
	endswitch;
	pop( ebx );
	pop( ecx );
	pop( edi );
	pop( esi );

end addval;









	


// subval-	Computes dest := dest - src.
//			Note: The caller is responsible for making dest
//			and src compatible.

procedure subval
( 
	var dest	:var;
	var	src		:var;
	var	vpt		:pType;
	var	typ		:var
);
begin subval;

	push( esi );
	push( edi );
	push( ecx );
	push( ebx );
	
	mov( dest, edi );
	mov( src, esi );
	mov( vpt, ebx );
	mov( typ, ecx );
	
	movzx( (type byte [ebx]), eax );
	switch( eax )
	
		case( tUns8 )
		
			mov( [esi], eax );
			sub( eax, [edi] );
			mov( 0, eax );		// Handle a possible borrow.
			sbb( 0, eax );
			mov( eax, [edi+4] );
			mov( eax, [edi+8] );
			mov( eax, [edi+12]);
			
			// If the value went negative, we need to
			// convert it to an INT8 or INT16 object:
			
			if( @s ) then
			
				mov( tInt16, (type byte [ebx]) );
				mov( &int16_ste, (type dword [ecx]) );
				
			endif;
			
			// Reduce the type of this object to it's smallest form:
			
			compactType( [edi], [ebx], [ecx] );
		
	
		case( tInt8 )
		
			// Note that we always maintain signed values
			// as 128-bit objects.  So we have to do a full
			// 128-bit add here:
			
			mov( [esi], eax );
			sub( eax, [edi] );
			mov( [esi+4], eax );
			sbb( eax, [edi+4] );
			mov( [esi+8], eax );
			sbb( eax, [edi+8] );
			mov( [esi+12], eax );
			sbb( eax, [edi+12] );
			
			// Reduce the type of this object to it's smallest form:
			
			compactType( [edi], [ebx], [ecx] );
		
	
	
		case( _tByte )
		
			// Note that we do *not* sign extend hex (byte/word/dword/etc)
			// results, even if the difference goes negative.
			
			mov( [esi], eax );
			sub( eax, [edi] );
			mov( 0, eax );
			sbb( 0, eax );
			mov( eax, [edi+4] );
			mov( eax, [edi+8] );
			mov( eax, [edi+12]);
			
			// Reduce the type of this object to it's smallest form:
			
			compactType( [edi], [ebx], [ecx] );
		
		
		
	
		case( tUns16 )
		
			mov( [esi], eax );
			sub( eax, [edi] );
			mov( 0, eax );		// Just to detect underflow.
			sbb( 0, eax );
			mov( eax, [edi+4] );
			mov( eax, [edi+8] );
			mov( eax, [edi+12]);
			
			// If the value went negative, we need to
			// convert it to an INT8, INT16, or INT32 object:
			
			if( @s ) then
			
				mov( tInt32, (type byte [ebx]) );
				mov( &int32_ste, (type dword [ecx]) );
				
			endif;
			
			// Reduce the type of this object to it's smallest form:
			
			compactType( [edi], [ebx], [ecx] );
		
	
		case( tInt16 )
		
			// Note that we always maintain signed values
			// as 128-bit objects.  So we have to do a full
			// 128-bit sub here:
			
			mov( [esi], eax );
			sub( eax, [edi] );
			mov( [esi+4], eax );
			sbb( eax, [edi+4] );
			mov( [esi+8], eax );
			sbb( eax, [edi+8] );
			mov( [esi+12], eax );
			sbb( eax, [edi+12] );
			
			// Reduce the type of this object to it's smallest form:
			
			compactType( [edi], [ebx], [ecx] );
		
	
		case( tWord )
		
			mov( [esi], eax );
			sub( eax, [edi] );
			mov( [esi+4], eax );
			sbb( eax, [edi+4] );
			mov( [esi+8], eax );
			sbb( eax, [edi+8] );
			mov( [esi+12], eax );
			sbb( eax, [edi+12] );
			
			// Reduce the type of this object to it's smallest form:
			
			compactType( [edi], [ebx], [ecx] );
		
	
		case( tUns32 )
		
			mov( [esi], eax );
			sub( eax, [edi] );
			mov( 0, eax );
			sbb( 0, eax );
			mov( eax, [edi+4] );
			mov( eax, [edi+8] );
			mov( eax, [edi+12]);
			
			// If the value went negative, we need to
			// convert it to an INT8, INT16, INT32, or INT64 object:
			
			if( @s ) then
			
				mov( tInt64, (type byte [ebx]));
				mov( &int64_ste, (type dword [ecx]));
				
			endif;

			// Reduce the type of this object to it's smallest form:
			
			compactType( [edi], [ebx], [ecx] );
		
	
		case( tInt32 )
		
			// Note that we always maintain signed values
			// as 128-bit objects.  So we have to do a full
			// 128-bit add here:
			
			mov( [esi], eax );
			sub( eax, [edi] );
			mov( [esi+4], eax );
			sbb( eax, [edi+4] );
			mov( [esi+8], eax );
			sbb( eax, [edi+8] );
			mov( [esi+12], eax );
			sbb( eax, [edi+12] );
			
			// Reduce the type of this object to it's smallest form:
			
			compactType( [edi], [ebx], [ecx] );
		
		
	
		case( tDWord )
		
			mov( [esi], eax );
			sub( eax, [edi] );
			mov( [esi+4], eax );
			sbb( eax, [edi+4] );
			mov( [esi+8], eax );
			sbb( eax, [edi+8] );
			mov( [esi+12], eax );
			sbb( eax, [edi+12] );
			
			// Reduce the type of this object to it's smallest form:
			
			compactType( [edi], [ebx], [ecx] );
				
			
			
		
		
	
		case( tUns64 ) 
		
			mov( [esi], eax );
			sub( eax, [edi] );
			mov( [esi+4], eax );
			sbb( eax, [edi+4] );
			mov( 0, eax );
			sbb( 0, eax );
			mov( eax, [edi+8] );
			mov( eax, [edi+12]);
			
			// If the value went negative, we need to
			// convert it to an INT8, INT16, INT32, INT64, or INT128 object:
			
			if( @s ) then

				mov( tInt128, (type byte [ebx]));
				mov( &int128_ste, (type dword [ecx]));
				
			endif;
			
			// Reduce the type of this object to it's smallest form:
			
			compactType( [edi], [ebx], [ecx] );
		
		
	
		case( tInt64 )
		
		
			// Note that we always maintain signed values
			// as 128-bit objects.  So we have to do a full
			// 128-bit add here:
			
			mov( [esi], eax );
			sub( eax, [edi] );
			mov( [esi+4], eax );
			sbb( eax, [edi+4] );
			mov( [esi+8], eax );
			sbb( eax, [edi+8] );
			mov( [esi+12], eax );
			sbb( eax, [edi+12] );
			
			// Reduce the type of this object to it's smallest form:
			
			compactType( [edi], [ebx], [ecx] );
		
		
	
		case( tQWord )
		
			mov( [esi], eax );
			sub( eax, [edi] );
			mov( [esi+4], eax );
			sbb( eax, [edi+4] );
			mov( 0, eax );
			sbb( 0, eax );
			mov( eax, [edi+8] );
			mov( eax, [edi+12]);
			
			// Reduce the type of this object to it's smallest form:
			
			compactType( [edi], [ebx], [ecx] );
		
		
	
		case( tTByte )
		
			mov( [esi], eax );
			sub( eax, [edi] );
			mov( [esi+4], eax );
			sbb( eax, [edi+4] );
			movzx( (type word [edi+8]), eax );
			sbb( 0, eax );
			mov( eax, [edi+8] );
			mov( eax, [edi+12]);
			
			// Reduce the type of this object to it's smallest form:
			
			compactType( [edi], [ebx], [ecx] );
			
			
		
		case( tUns128 )
		
			// No way to deal with overflow, so ignore it:
			
			mov( [esi], eax );
			sub( eax, [edi] );
			mov( [esi+4], eax );
			sbb( eax, [edi+4] );
			mov( [esi+8], eax );
			sbb( eax, [edi+8] );
			mov( [esi+12], eax );
			sbb( eax, [edi+12] );
				
			// Reduce the type of this object to it's smallest form:
			
			compactType( [edi], [ebx], [ecx] );
			
			
			
		case( tLWord )
		
			// No way to deal with overflow, so ignore it:
			
			mov( [esi], eax );
			sub( eax, [edi] );
			mov( [esi+4], eax );
			sbb( eax, [edi+4] );
			mov( [esi+8], eax );
			sbb( eax, [edi+8] );
			mov( [esi+12], eax );
			sbb( eax, [edi+12] );
				
			// Reduce the type of this object to it's smallest form:
			
			compactType( [edi], [ebx], [ecx] );
			
			
		case( tInt128 )
		
			// No way to deal with overflow, so ignore it:
			
			mov( [esi], eax );
			sub( eax, [edi] );
			mov( [esi+4], eax );
			sbb( eax, [edi+4] );
			mov( [esi+8], eax );
			sbb( eax, [edi+8] );
			mov( [esi+12], eax );
			sbb( eax, [edi+12] );

				
			// Reduce the type of this object to it's smallest form:
			
			compactType( [edi], [ebx], [ecx] );
				
			
			
			
		case( tReal32 )
		
			fld( (type real32 [esi]) );
			fld( (type real32 [edi]) );
			fsubrp();
			fstp( (type real32 [edi]) );
			xor( eax, eax );
			mov( eax, [edi+4] );
			mov( eax, [edi+8] );
			mov( eax, [edi+12] );
			
		case( tReal64 )
		
			fld( (type real64 [esi]) );
			fld( (type real64 [edi]) );
			fsubrp();
			fstp( (type real64 [edi]) );
			xor( eax, eax );
			mov( eax, [edi+8] );
			mov( eax, [edi+12] );
			
		case( tReal80 )
		
			fld( (type real80 [esi]) );
			fld( (type real80 [edi]) );
			fsubrp();
			fstp( (type real80 [edi]) );
			xor( eax, eax );
			mov( ax, [edi+10] );
			mov( eax, [edi+12] );
			
			
		case( tCset )
		
			// Do set difference here.  Note that
			// set difference is dest := dest and (not src)
			
			mov( [esi], eax );
			not( eax );
			and( eax, [edi] );
			mov( [esi+4], eax );
			not( eax );
			and( eax, [edi+4] );
			mov( [esi+8], eax );
			not( eax );
			and( eax, [edi+8] );
			mov( [esi+12], eax );
			not( eax );
			and( eax, [edi+12] );
			
	endswitch;
	pop( ebx );
	pop( ecx );
	pop( edi );
	pop( esi );

end subval;




// mulval-	Computes dest = left * right.
//			Works with unsigned, signed, hex, real, and cset values.


procedure mulval
( 
	var dest	:var;
	var	src		:var;
	var	vpt		:pType;
	var	typ		:var
);

const
	d	:text := "(type dword [edi])";
	s	:text := "(type dword [esi])";

var
	product: dword[4];
	
	
	
	procedure mul128; @noframe;
	begin mul128;
	
		push( edx );
	
	    // Multiply the L.O. dword of Multiplier times Multiplicand.
	                                           
	    mov( s[0*4], eax );
	    mul( d[0*4], eax );	
	    mov( eax, ebp::product[0*4] );
	    mov( edx, ebp::product[1*4] );

	    mov( s[0*4], eax );
	    mul( d[1*4], eax );
	    add( eax, ebp::product[1*4] );   
	    adc( 0, edx );     
	    mov( edx, ebp::product[2*4] );

	    mov( s[0*4], eax );
	    mul( d[2*4], eax );
	    add( eax, ebp::product[2*4] );   
	    adc( 0, edx );     
	    mov( edx, ebp::product[3*4] );

	    mov( s[0*4], eax );
	    mul( d[3*4], eax );
	    add( eax, ebp::product[3*4] );	// Ignore any overflow.   


	    // Multiply the second dword of Multiplier times Multiplicand.
	                                           
	    mov( s[1*4], eax );
	    mul( d[0*4], eax );	
	    add( eax, ebp::product[1*4] );
	    adc( edx, ebp::product[2*4] );

	    mov( s[1*4], eax );
	    mul( d[1*4], eax );
	    add( eax, ebp::product[2*4] );   
	    adc( edx, ebp::product[3*4] );

	    mov( s[1*4], eax );
	    mul( d[2*4], eax );
	    add( eax, ebp::product[3*4] );	// Ignore any overflow   


	    // Multiply the third dword of Multiplier times Multiplicand.
	                                           
	    mov( s[2*4], eax );
	    mul( d[0*4], eax );	
	    add( eax, ebp::product[2*4] );
	    adc( edx, ebp::product[3*4] );

	    mov( s[2*4], eax );
	    mul( d[1*4], eax );
	    add( eax, ebp::product[3*4] );	// Ignore any overflow   


	    // Multiply the fourth dword of Multiplier times Multiplicand.
	                                           
	    mov( s[3*4], eax );
	    mul( d[0*4], eax );	
	    add( eax, ebp::product[3*4] );	// Ignore any overflow
		
		// Okay, now copy the product value to the destination:
		
		mov( ebp::product[0*4], eax );
		mov( eax, d[0*4] );
		mov( ebp::product[1*4], eax );
		mov( eax, d[1*4] );
		mov( ebp::product[2*4], eax );
		mov( eax, d[2*4] );
		mov( ebp::product[3*4], eax );
		mov( eax, d[3*4] );
		   

		pop( edx );
		ret();
		
	end mul128;
	
begin mulval;

	push( ebx );
	push( ecx );
	push( esi );
	push( edi );
	
	mov( src, esi );
	mov( dest, edi );
	mov( typ, ecx );
	mov( vpt, ebx );
	movzx( (type byte [ebx]), eax );
	switch( eax )
	
		case
		(
			tUns8,
			tUns16,
			tUns32,
			tUns64,
			tUns128
		)
		
			call mul128;
			
			// If the result fits into 8, 16, 32, or 64 bits, shrink
			// the size down:
				
			mov( tUns128, (type byte [ebx]));
			mov( &uns128_ste, (type dword [ecx]));
			if( d[8] = 0 && d[12] = 0 ) then
			
				mov( tUns64, (type byte [ebx]));
				mov( &uns64_ste, (type dword [ecx]));
				if( d[4] = 0 ) then
				
					mov( tUns32, (type byte [ebx]));
					mov( &uns32_ste, (type dword [ecx]));
					if( (type word [edi+2]) = 0 ) then
					
						mov( tUns16, (type byte [ebx]));
						mov( &uns16_ste, (type dword [ecx]));
						if( (type byte [edi+1]) = 0 ) then
						
							mov( tUns8, (type byte [ebx]));
							mov( &uns8_ste, (type dword [ecx]));
							
						endif;
						
					endif;
					
				endif;
				
			endif;
	
	
	
	
	
		case
		(
			_tByte,
			tWord,
			tDWord,
			tQWord,
			tTByte,
			tLWord
		)
		
			call mul128;
				
			// If the result fits into 8, 16, 32, or 64 bits, shrink
			// the size down:
				
			mov( tLWord, (type byte [ebx]));
			mov( &lword_ste, (type dword [ecx]));
			if( (type word [edi+10]) = 0 && (type dword [edi+12]) = 0 ) then
			
				mov( tTByte, (type byte [ebx]));
				mov( &tbyte_ste, (type dword [ecx]));
				if( (type word [edi+8]) = 0 ) then
				
					mov( tQWord, (type byte [ebx]));
					mov( &qword_ste, (type dword [ecx]));
					if( (type dword [edi+4]) = 0 ) then
					
						mov( tDWord, (type byte [ebx]));
						mov( &dword_ste, (type dword [ecx]));
						if( (type word [edi+2]) = 0 ) then
						
							mov( tWord, (type byte [ebx]));
							mov( &word_ste, (type dword [ecx]));
							if( (type byte [edi+1]) = 0 ) then
							
								mov( _tByte, (type byte [ebx]));
								mov( &byte_ste, (type dword [ecx]));
								
							endif;
							
						endif;
						
					endif;
					
				endif;
				
			endif;
			
			
			
			
		case
		(
			tInt8,
			tInt16,
			tInt32,
			tInt64,
			tInt128
		)
		
			// Note: this code assumes that all IntXX objects
			// are sign extended to 128 bits.
			
			// Compute the result sign and then take the
			// absolute value of the two operands (since mul128
			// only works on unsigned operands).
			
			mov( [edi+15], al );	// Compute sign of result into
			xor( [esi+15], al );	//  the sign flag.
			pushfd();
			
			if( (type int8 [edi+15]) < 0 ) then
			
				xor( eax, eax );
				sub( d[0*4], eax );
				mov( eax, d[0*4] );
				
				mov( 0, eax );
				sbb( d[1*4], eax );
				mov( eax, d[1*4] );
				
				mov( 0, eax );
				sbb( d[2*4], eax );
				mov( eax, d[2*4] );
				
				mov( 0, eax );
				sbb( d[3*4], eax );
				mov( eax, d[3*4] );
				
			endif;
			
			if( (type int8 [esi+15]) < 0 ) then
			
				xor( eax, eax );
				sub( s[0*4], eax );
				mov( eax, s[0*4] );
				
				mov( 0, eax );
				sbb( s[1*4], eax );
				mov( eax, s[1*4] );
				
				mov( 0, eax );
				sbb( s[2*4], eax );
				mov( eax, s[2*4] );
				
				mov( 0, eax );
				sbb( s[3*4], eax );
				mov( eax, s[3*4] );
				
			endif;
				 
			call mul128;
			
			// If the product is negative, negate the result:
			
			popfd();
			if( @s ) then
			
				xor( eax, eax );
				sub( d[0*4], eax );
				mov( eax, d[0*4] );
				
				mov( 0, eax );
				sbb( d[1*4], eax );
				mov( eax, d[1*4] );
				
				mov( 0, eax );
				sbb( d[2*4], eax );
				mov( eax, d[2*4] );
				
				mov( 0, eax );
				sbb( d[3*4], eax );
				mov( eax, d[3*4] );
				
			endif;
			
			// If the result fits into 8, 16, 32, or 64 bits, shrink
			// the size down:
				
			mov( tInt128, (type byte [ebx]));
			mov( &int128_ste, (type dword [ecx]));
			movsx( (type byte [edi+7]), eax );
			mov( ah, al );
			if( eax = [edi+8] && eax = [edi+12] ) then
			
				mov( tInt64, (type byte [ebx]));
				mov( &int64_ste, (type dword [ecx]));
				movsx( (type byte [edi+3]), eax );
				mov( ah, al );
				if( eax = [edi+4] ) then
				
					mov( tInt32, (type byte [ebx]));
					mov( &int32_ste, (type dword [ecx]));
					movsx( (type byte [edi+1]), eax );
					mov( ah, al );
					if( (type word [edi+2]) = ax ) then
					
						mov( tInt16, (type byte [ebx]));
						mov( &int16_ste, (type dword [ecx]));
						movsx( (type byte [edi]), ax );
						if( (type byte [edi+1]) = ah ) then
						
							mov( tInt8, (type byte [ebx]));
							mov( &int8_ste, (type dword [ecx]));
							
						endif;
						
					endif;
					
				endif;
				
			endif;
	
	
		case( tReal32 )

			fld( (type real32 [esi]) );
			fld( (type real32 [edi]) );
			fmulp();
			fstp( (type real80 [edi]) );	
			mov( tReal80, (type byte [ebx]));
			mov( &real80_ste, (type dword [ecx]));


		case( tReal64 )
		
			fld( (type real64 [esi]) );
			fld( (type real64 [edi]) );
			fmulp();
			fstp( (type real80 [edi]) );	
			mov( tReal80, (type byte [ebx]));
			mov( &real80_ste, (type dword [ecx]));
	
	
		case( tReal80 )
		
			fld( (type real80 [esi]) );
			fld( (type real80 [edi]) );
			fmulp();
			fstp( (type real80 [edi]) );
			
		
		case( tCset )
		
			// For character sets, the "*" operator means intersection.
			// Set intersection is dest := dest and src
			
			mov( s[0*4], eax );
			and( eax, d[0*4] );
			mov( s[1*4], eax );
			and( eax, d[1*4] );
			mov( s[2*4], eax );
			and( eax, d[2*4] );
			mov( s[3*4], eax );
			and( eax, d[3*4] );
			
	endswitch;		
	pop( edi );
	pop( esi );
	pop( ecx );
	pop( ebx );

end mulval;	
	






// div128-  used by divval and modval.
//
// This procedure does a general 128/128 division operation
// using the following algorithm:
// (all variables are assumed to be 128 bit objects)
//
// Quotient := Dividend;
// Remainder := 0;
// for i:= 1 to NumberBits do
// 
//  Remainder:Quotient := Remainder:Quotient SHL 1;
//  if Remainder >= Divisor then
// 
//      Remainder := Remainder - Divisor;
//      Quotient := Quotient + 1;
// 
//  endif
// endfor
// 

type _lword: dword[4];

procedure div128
( 
    	Dividend:   _lword; 
    	Divisor:    _lword; 
    var QuotAdrs:   var; 
    var RmndrAdrs:  var 
);  @nodisplay;

const
    Quotient: text := "Dividend";   // Use the Dividend as the Quotient.

var
    Remainder: dword[4];

begin div128;

    push( eax );
    push( ecx );
    push( edi );
    
    mov( 0, eax );              // Set the remainder to zero.
    mov( eax, Remainder[0*1] );
    mov( eax, Remainder[1*4] );
    mov( eax, Remainder[2*4] );
    mov( eax, Remainder[3*4] );

    mov( 128, ecx );            // Count off 128 bits in ECX.
    repeat

        // Compute Remainder:Quotient := Remainder:Quotient SHL 1:

        shl( 1, (type dword Dividend[0*4]) );	// See the section on extended
        rcl( 1, (type dword Dividend[1*4]) );	// precision shifts to see how
        rcl( 1, (type dword Dividend[2*4]) );	// this code shifts 128 bits to
        rcl( 1, (type dword Dividend[3*4]) );	// the left by one bit.
        rcl( 1, (type dword Remainder[0*4]) );
        rcl( 1, (type dword Remainder[1*4]) );
        rcl( 1, (type dword Remainder[2*4]) );
        rcl( 1, (type dword Remainder[3*4]) );

        // Do a 64-bit comparison to see if the remainder
        // is greater than or equal to the divisor.

        if
        ( #{
            mov( Remainder[3*4], eax );
            cmp( eax, (type dword Divisor[3*4]) );
            ja true;
            jb false;
            mov( Remainder[2*4], eax );
            cmp( eax, (type dword Divisor[2*4]) );
            ja true;
            jb false;
            mov( Remainder[1*4], eax );
            cmp( eax, (type dword Divisor[1*4]) );
            ja true;
            jb false;

            mov( Remainder[0*4], eax );
            cmp( eax, (type dword Divisor[0*4]) );
            jb false;
        }# ) then

            // Remainder := Remainder - Divisor

            mov( (type dword Divisor[0*4]), eax );
            sub( eax, Remainder[0*4] );
            mov( (type dword Divisor[1*4]), eax );
            sbb( eax, Remainder[1*4] );
            mov( (type dword Divisor[2*4]), eax );
            sbb( eax, Remainder[2*4] );
            mov( (type dword Divisor[3*4]), eax );
            sbb( eax, Remainder[3*4] );

            // Quotient := Quotient + 1;

            add( 1, (type dword Quotient[0*4]) );
            adc( 0, (type dword Quotient[1*4]) );
            adc( 0, (type dword Quotient[2*4]) );
            adc( 0, (type dword Quotient[3*4]) );

        endif;
        dec( ecx );

    until( @z );


    // Okay, copy the quotient (left in the Dividend variable)
    // and the remainder to their return locations.
    
    mov( QuotAdrs, edi );
    mov( (type dword Quotient[0*4]), eax );
    mov( eax, [edi] );
    mov( (type dword Quotient[1*4]), eax );
    mov( eax, [edi+4] );
    mov( (type dword Quotient[2*4]), eax );
    mov( eax, [edi+8] );
    mov( (type dword Quotient[3*4]), eax );
    mov( eax, [edi+12] );
    
    mov( RmndrAdrs, edi );
    mov( Remainder[0*4], eax );
    mov( eax, [edi] );
    mov( Remainder[1*4], eax );
    mov( eax, [edi+4] );
    mov( Remainder[2*4], eax );
    mov( eax, [edi+8] );
    mov( Remainder[3*4], eax );
    mov( eax, [edi+12] );
         
    pop( edi );
    pop( ecx );
    pop( eax );
            
end div128;








// divval-	Computes dest = left / right.
//			Works with unsigned, signed, hex, and real values.


procedure divval
( 
	var dest	:var;
	var	src		:var;
	var	vpt		:pType;
	var	typ		:var
);

const
	d	:text := "(type dword [edi])";
	s	:text := "(type dword [esi])";
	
var
	Remainder: dword[4];

begin divval;

	push( ebx );
	push( ecx );
	push( esi );
	push( edi );
	
	mov( src, esi );
	mov( dest, edi );
	mov( typ, ecx );
	mov( vpt, ebx );
	movzx( (type byte [ebx]), eax );
	switch( eax )
	
		case
		(
			tUns8,
			tUns16,
			tUns32,
			tUns64,
			tUns128
		)
		
			mov( [esi], eax );
			or( [esi+4], eax );
			or( [esi+8], eax );
			or( [esi+12], eax );
			if( @z ) then
			
				yyerror( "Attempted division by zero" );
				mov( 1, (type byte [esi]));
				
			endif;
			div128
			( 
				(type _lword [edi]), 
				(type _lword [esi]), 
				[edi], 
				Remainder 
			);
			
			// If the result fits into 8, 16, 32, or 64 bits, shrink
			// the size down:
				
			mov( tUns128, (type byte [ebx]));
			mov( &uns128_ste, (type dword [ecx]));
			if( d[8] = 0 && d[12] = 0 ) then
			
				mov( tUns64, (type byte [ebx]));
				mov( &uns64_ste, (type dword [ecx]));
				if( d[4] = 0 ) then
				
					mov( tUns32, (type byte [ebx]));
					mov( &uns32_ste, (type dword [ecx]));
					if( (type word [edi+2]) = 0 ) then
					
						mov( tUns16, (type byte [ebx]));
						mov( &uns16_ste, (type dword [ecx]));
						if( (type byte [edi+1]) = 0 ) then
						
							mov( tUns8, (type byte [ebx]));
							mov( &uns8_ste, (type dword [ecx]));
							
						endif;
						
					endif;
					
				endif;
				
			endif;
	
	
	
	
		case
		(
			_tByte,
			tWord,
			tDWord,
			tQWord,
			tTByte,
			tLWord
		)
		
			mov( [esi], eax );
			or( [esi+4], eax );
			or( [esi+8], eax );
			or( [esi+12], eax );
			if( @z ) then
			
				yyerror( "Attempted division by zero" );
				mov( 1, (type byte [esi]));
				
			endif;
			div128
			( 
				(type _lword [edi]), 
				(type _lword [esi]), 
				[edi], 
				Remainder 
			);
							
			// If the result fits into 8, 16, 32, or 64 bits, shrink
			// the size down:
				
			mov( tLWord, (type byte [ebx]));
			mov( &lword_ste, (type dword [ecx]));
			if( (type word [edi+10]) = 0 && (type dword [edi+12]) = 0 ) then
			
				mov( tTByte, (type byte [ebx]));
				mov( &tbyte_ste, (type dword [ecx]));
				if( (type word [edi+8]) = 0 ) then
				
					mov( tQWord, (type byte [ebx]));
					mov( &qword_ste, (type dword [ecx]));
					if( (type dword [edi+4]) = 0 ) then
					
						mov( tDWord, (type byte [ebx]));
						mov( &dword_ste, (type dword [ecx]));
						if( (type word [edi+2]) = 0 ) then
						
							mov( tWord, (type byte [ebx]));
							mov( &word_ste, (type dword [ecx]));
							if( (type byte [edi+1]) = 0 ) then
							
								mov( _tByte, (type byte [ebx]));
								mov( &byte_ste, (type dword [ecx]));
								
							endif;
							
						endif;
						
					endif;
					
				endif;
				
			endif;
			
			
			
			
		case
		(
			tInt8,
			tInt16,
			tInt32,
			tInt64,
			tInt128
		)
		
			// Note: this code assumes that all IntXX objects
			// are sign extended to 128 bits.
			
			// Compute the result sign and then take the
			// absolute value of the two operands (since mul128
			// only works on unsigned operands).
			
			mov( [edi+15], al );	// Compute sign of result into
			xor( [esi+15], al );	//  the sign flag.
			pushfd();
			
			if( (type int8 [edi+15]) < 0 ) then
			
				xor( eax, eax );
				sub( d[0*4], eax );
				mov( eax, d[0*4] );
				
				mov( 0, eax );
				sbb( d[1*4], eax );
				mov( eax, d[1*4] );
				
				mov( 0, eax );
				sbb( d[2*4], eax );
				mov( eax, d[2*4] );
				
				mov( 0, eax );
				sbb( d[3*4], eax );
				mov( eax, d[3*4] );
				
			endif;
			
			if( (type int8 [esi+15]) < 0 ) then
			
				xor( eax, eax );
				sub( s[0*4], eax );
				mov( eax, s[0*4] );
				
				mov( 0, eax );
				sbb( s[1*4], eax );
				mov( eax, s[1*4] );
				
				mov( 0, eax );
				sbb( s[2*4], eax );
				mov( eax, s[2*4] );
				
				mov( 0, eax );
				sbb( s[3*4], eax );
				mov( eax, s[3*4] );
				
			endif;
				 
			mov( [esi], eax );
			or( [esi+4], eax );
			or( [esi+8], eax );
			or( [esi+12], eax );
			if( @z ) then
			
				yyerror( "Attempted division by zero" );
				mov( 1, (type byte [esi]));
				
			endif;
			div128
			( 
				(type _lword [edi]), 
				(type _lword [esi]), 
				[edi], 
				Remainder 
			);
			
			// If the quotient is negative, negate the result:
			
			popfd();
			if( @s ) then
			
				xor( eax, eax );
				sub( d[0*4], eax );
				mov( eax, d[0*4] );
				
				mov( 0, eax );
				sbb( d[1*4], eax );
				mov( eax, d[1*4] );
				
				mov( 0, eax );
				sbb( d[2*4], eax );
				mov( eax, d[2*4] );
				
				mov( 0, eax );
				sbb( d[3*4], eax );
				mov( eax, d[3*4] );
				
			endif;
			
			// If the result fits into 8, 16, 32, or 64 bits, shrink
			// the size down:
				
			mov( tInt128, (type byte [ebx]));
			mov( &int128_ste, (type dword [ecx]));
			movsx( (type byte [edi+7]), eax );
			mov( ah, al );
			if( eax = [edi+8] && eax = [edi+12] ) then
			
				mov( tInt64, (type byte [ebx]));
				mov( &int64_ste, (type dword [ecx]));
				movsx( (type byte [edi+3]), eax );
				mov( ah, al );
				if( eax = [edi+4] ) then
				
					mov( tInt32, (type byte [ebx]));
					mov( &int32_ste, (type dword [ecx]));
					movsx( (type byte [edi+1]), eax );
					mov( ah, al );
					if( (type word [edi+2]) = ax ) then
					
						mov( tInt16, (type byte [ebx]));
						mov( &int16_ste, (type dword [ecx]));
						movsx( (type byte [edi]), ax );
						if( (type byte [edi+1]) = ah ) then
						
							mov( tInt8, (type byte [ebx]));
							mov( &int8_ste, (type dword [ecx]));
							
						endif;
						
					endif;
					
				endif;
				
			endif;
	
	
		case( tReal32 )

			// Note: real32 values are zero only if all bits are zero.
			
			if( (type dword [esi]) = 0 ) then
			
				yyerror( "Attempted division by zero" );
				mov( $3F80_0000, (type dword [esi]));		//1.0
				
			endif;
			fld( (type real32 [esi]) );
			fld( (type real32 [edi]) );
			fdivrp();
			fstp( (type real80 [edi]) );	
			mov( tReal80, (type byte [ebx]));
			mov( &real80_ste, (type dword [ecx]));


		case( tReal64 )
		
			// Note: real64 values are zero only if all 64 bits are zero.
			
			if( (type dword [esi]) = 0 && (type dword [esi+4]) = 0 ) then
			
				yyerror( "Attempted division by zero" );
				mov( $3FF0_0000, (type dword [esi+4]));		//1.0
				mov( 0, (type dword [esi]));
				
			endif;
		
			fld( (type real64 [esi]) );
			fld( (type real64 [edi]) );
			fdivrp();
			fstp( (type real80 [edi]) );	
			mov( tReal80, (type byte [ebx]));
			mov( &real80_ste, (type dword [ecx]));
	
	
		case( tReal80 )
		
			// Note: real80 values are zero only if all 80 bits are zero.
			
			if
			( 
					(type dword [esi]) = 0 
				&&	(type dword [esi+4]) = 0
				&&	(type word [esi+8]) = 0 
			) then
			
				yyerror( "Attempted division by zero" );
				mov( $3FFF_8000, (type dword [esi+6]));		//1.0
				mov( 0, (type word [esi+4]));
				mov( 0, (type dword [esi]));
				
			endif;
			fld( (type real80 [esi]) );
			fld( (type real80 [edi]) );
			fdivrp();
			fstp( (type real80 [edi]) );
			
		
	endswitch;		
	pop( edi );
	pop( esi );
	pop( ecx );
	pop( ebx );

end divval;	
	






// modval-	Computes dest = left % right.
//			Works with unsigned, signed, hex, and real values.


procedure modval
( 
	var dest	:var;
	var	src		:var;
	var	vpt		:pType;
	var	typ		:var
);

const
	d	:text := "(type dword [edi])";
	s	:text := "(type dword [esi])";
	
var
	Quotient: dword[4];

begin modval;

	push( ebx );
	push( ecx );
	push( esi );
	push( edi );
	
	mov( src, esi );
	mov( dest, edi );
	mov( typ, ecx );
	mov( vpt, ebx );
	movzx( (type byte [ebx]), eax );
	switch( eax )
	
		case
		(
			tUns8,
			tUns16,
			tUns32,
			tUns64,
			tUns128
		)
		
			mov( [esi], eax );
			or( [esi+4], eax );
			or( [esi+8], eax );
			or( [esi+12], eax );
			if( @z ) then
			
				yyerror( "Attempted division by zero" );
				mov( 1, (type byte [esi]));
				
			endif;
			div128
			( 
				(type _lword [edi]), 
				(type _lword [esi]), 
				Quotient,
				[edi] 
			);
			
			// If the result fits into 8, 16, 32, or 64 bits, shrink
			// the size down:
				
			mov( tUns128, (type byte [ebx]));
			mov( &uns128_ste, (type dword [ecx]));
			if( d[8] = 0 && d[12] = 0 ) then
			
				mov( tUns64, (type byte [ebx]));
				mov( &uns64_ste, (type dword [ecx]));
				if( d[4] = 0 ) then
				
					mov( tUns32, (type byte [ebx]));
					mov( &uns32_ste, (type dword [ecx]));
					if( (type word [edi+2]) = 0 ) then
					
						mov( tUns16, (type byte [ebx]));
						mov( &uns16_ste, (type dword [ecx]));
						if( (type byte [edi+1]) = 0 ) then
						
							mov( tUns8, (type byte [ebx]));
							mov( &uns8_ste, (type dword [ecx]));
							
						endif;
						
					endif;
					
				endif;
				
			endif;
	
	
	
	
	
		case
		(
			_tByte,
			tWord,
			tDWord,
			tQWord,
			tTByte,
			tLWord
		)
		
			mov( [esi], eax );
			or( [esi+4], eax );
			or( [esi+8], eax );
			or( [esi+12], eax );
			if( @z ) then
			
				yyerror( "Attempted division by zero" );
				mov( 1, (type byte [esi]));
				
			endif;
			div128
			( 
				(type _lword [edi]), 
				(type _lword [esi]), 
				Quotient,
				[edi] 
			);
							
			// If the result fits into 8, 16, 32, or 64 bits, shrink
			// the size down:
				
			mov( tLWord, (type byte [ebx]));
			mov( &lword_ste, (type dword [ecx]));
			if( (type word [edi+10]) = 0 && (type dword [edi+12]) = 0 ) then
			
				mov( tTByte, (type byte [ebx] ));
				mov( &tbyte_ste, (type dword [ecx]));
				if( (type word [edi+8]) = 0 ) then
				
					mov( tQWord, (type byte [ebx]));
					mov( &qword_ste, (type dword [ecx]));
					if( (type dword [edi+4]) = 0 ) then
					
						mov( tDWord, (type byte [ebx]));
						mov( &dword_ste, (type dword [ecx]));
						if( (type word [edi+2]) = 0 ) then
						
							mov( tWord, (type byte [ebx]));
							mov( &word_ste, (type dword [ecx]));
							if( (type byte [edi+1]) = 0 ) then
							
								mov( _tByte, (type byte [ebx]));
								mov( &byte_ste, (type dword [ecx]));
								
							endif;
							
						endif;
						
					endif;
					
				endif;
				
			endif;
				
			
			
			
		case
		(
			tInt8,
			tInt16,
			tInt32,
			tInt64,
			tInt128
		)
		
			// Note: this code assumes that all IntXX objects
			// are sign extended to 128 bits.
			
			// Compute the result sign and then take the
			// absolute value of the two operands (since mul128
			// only works on unsigned operands).
			
			mov( [edi+15], al );	// Compute sign of result into
			xor( [esi+15], al );	//  the sign flag.
			pushfd();
			
			if( (type int8 [edi+15]) < 0 ) then
			
				xor( eax, eax );
				sub( d[0*4], eax );
				mov( eax, d[0*4] );
				
				mov( 0, eax );
				sbb( d[1*4], eax );
				mov( eax, d[1*4] );
				
				mov( 0, eax );
				sbb( d[2*4], eax );
				mov( eax, d[2*4] );
				
				mov( 0, eax );
				sbb( d[3*4], eax );
				mov( eax, d[3*4] );
				
			endif;
			
			if( (type int8 [esi+15]) < 0 ) then
			
				xor( eax, eax );
				sub( s[0*4], eax );
				mov( eax, s[0*4] );
				
				mov( 0, eax );
				sbb( s[1*4], eax );
				mov( eax, s[1*4] );
				
				mov( 0, eax );
				sbb( s[2*4], eax );
				mov( eax, s[2*4] );
				
				mov( 0, eax );
				sbb( s[3*4], eax );
				mov( eax, s[3*4] );
				
			endif;
				 
			mov( [esi], eax );
			or( [esi+4], eax );
			or( [esi+8], eax );
			or( [esi+12], eax );
			if( @z ) then
			
				yyerror( "Attempted division by zero" );
				mov( 1, (type byte [esi]));
				
			endif;
			div128
			( 
				(type _lword [edi]), 
				(type _lword [esi]), 
				Quotient,
				[edi] 
			);
			
			// If the quotient is negative, negate the result:
			
			popfd();
			if( @s ) then
			
				xor( eax, eax );
				sub( d[0*4], eax );
				mov( eax, d[0*4] );
				
				mov( 0, eax );
				sbb( d[1*4], eax );
				mov( eax, d[1*4] );
				
				mov( 0, eax );
				sbb( d[2*4], eax );
				mov( eax, d[2*4] );
				
				mov( 0, eax );
				sbb( d[3*4], eax );
				mov( eax, d[3*4] );
				
			endif;
			
			// If the result fits into 8, 16, 32, or 64 bits, shrink
			// the size down:
				
			mov( tInt128, (type byte [ebx]));
			mov( &int128_ste, (type dword [ecx]));
			movsx( (type byte [edi+7]), eax );
			mov( ah, al );
			if( eax = [edi+8] && eax = [edi+12] ) then
			
				mov( tInt64, (type byte [ebx]));
				mov( &int64_ste, (type dword [ecx]));
				movsx( (type byte [edi+3]), eax );
				mov( ah, al );
				if( eax = [edi+4] ) then
				
					mov( tInt32, (type byte [ebx]));
					mov( &int32_ste, (type dword [ecx]));
					movsx( (type byte [edi+1]), eax );
					mov( ah, al );
					if( (type word [edi+2]) = ax ) then
					
						mov( tInt16, (type byte [ebx]));
						mov( &int16_ste, (type dword [ecx]));
						movsx( (type byte [edi]), ax );
						if( (type byte [edi+1]) = ah ) then
						
							mov( tInt8, (type byte [ebx]));
							mov( &int8_ste, (type dword [ecx]));
							
						endif;
						
					endif;
					
				endif;
				
			endif;
			
		
	endswitch;		
	pop( edi );
	pop( esi );
	pop( ecx );
	pop( ebx );

end modval;	
	




procedure shlval
( 
	var dest	:var;
	var	cnt		:var;
	var	vpt		:pType;
	var	typ		:var
);
begin shlval;

	push( edi );
	push( ecx );
	
	mov( dest, edi );
	mov( cnt, ecx );
	mov( [ecx], ecx );
	test( ecx, ecx );
	while( @nz ) do
		
		shl( 1, (type dword [edi]));
		rcl( 1, (type dword [edi+4]));
		rcl( 1, (type dword [edi+8]));
		rcl( 1, (type dword [edi+12]));
		dec( ecx );
		
	endwhile;
	
	compactType( [edi], vpt, typ );
	
	pop( ecx );
	pop( edi );			
		
end shlval;








procedure shrval
( 
	var dest	:var;
	var	cnt		:var;
	var	vpt		:pType;
	var	typ		:var
);
begin shrval;

	push( edi );
	push( ecx );
	
	mov( dest, edi );
	mov( cnt, ecx );
	mov( [ecx], ecx );
	test( ecx, ecx );
	while( @nz ) do
		
		shr( 1, (type dword [edi+12]));
		rcr( 1, (type dword [edi+8]));
		rcr( 1, (type dword [edi+4]));
		rcr( 1, (type dword [edi+0]));
		dec( ecx );
		
	endwhile;
	
	compactType( [edi], vpt, typ );
	
	pop( ecx );
	pop( edi );			
		
end shrval;






procedure bigmaxUns( var dest:var; var left:var; var right:var );
begin bigmaxUns;

	push( esi );
	push( edi );
	mov( left, esi );
	mov( right, edi );
	
	mov( [esi+12], eax );
	cmp( eax, [edi+12] );
	jb setRight;
	ja setLeft;
	
	mov( [esi+8], eax );
	cmp( eax, [edi+8] );
	jb setRight;
	ja setLeft;
	
	mov( [esi+4], eax );
	cmp( eax, [edi+4] );
	jb setRight;
	ja setLeft;
	
	mov( [esi], eax );
	cmp( eax, [edi] );
	jb setRight;

  setLeft:
  	mov( dest, edi );
	mov( eax, [edi] );
	mov( [esi+4], eax );
	mov( eax, [edi+4] );
	mov( [esi+8], eax );
	mov( eax, [edi+8] );
	mov( [esi+12], eax );
	mov( eax, [edi+12] );
	jmp bmux;
	
  setRight:
  	mov( dest, esi );
	mov( [edi], eax );
	mov( eax, [esi] );
	mov( [edi+4], eax );
	mov( eax, [esi+4] );
	mov( [edi+8], eax );
	mov( eax, [esi+8] );
	mov( [edi+12], eax );
	mov( eax, [esi+12] );
	
  bmux:
  	pop( edi );
	pop( esi );

end bigmaxUns;


	
procedure bigmaxInt( var dest:var; var left:var; var right:var );
begin bigmaxInt;

	push( esi );
	push( edi );
	mov( left, esi );
	mov( right, edi );
	
	mov( [esi+12], eax );
	cmp( eax, [edi+12] );
	jl setRight;
	jg setLeft;
	
	mov( [esi+8], eax );
	cmp( eax, [edi+8] );
	jl setRight;
	jg setLeft;
	
	mov( [esi+4], eax );
	cmp( eax, [edi+4] );
	jl setRight;
	jg setLeft;
	
	mov( [esi], eax );
	cmp( eax, [edi] );
	jl setRight;

  setLeft:
  	mov( dest, edi );
	mov( eax, [edi] );
	mov( [esi+4], eax );
	mov( eax, [edi+4] );
	mov( [esi+8], eax );
	mov( eax, [edi+8] );
	mov( [esi+12], eax );
	mov( eax, [edi+12] );
	jmp bmux;
	
  setRight:
  	mov( dest, esi );
	mov( [edi], eax );
	mov( eax, [esi] );
	mov( [edi+4], eax );
	mov( eax, [esi+4] );
	mov( [edi+8], eax );
	mov( eax, [esi+8] );
	mov( [edi+12], eax );
	mov( eax, [esi+12] );
	
  bmux:
  	pop( edi );
	pop( esi );

end bigmaxInt;
	
	
procedure bigminUns( var dest:var; var left:var; var right:var );
begin bigminUns;

	push( esi );
	push( edi );
	mov( left, esi );
	mov( right, edi );
	
	mov( [esi+12], eax );
	cmp( eax, [edi+12] );
	ja setRight;
	jb setLeft;
	
	mov( [esi+8], eax );
	cmp( eax, [edi+8] );
	ja setRight;
	jb setLeft;
	
	mov( [esi+4], eax );
	cmp( eax, [edi+4] );
	ja setRight;
	jb setLeft;
	
	mov( [esi], eax );
	cmp( eax, [edi] );
	ja setRight;

  setLeft:
  	mov( dest, edi );
	mov( eax, [edi] );
	mov( [esi+4], eax );
	mov( eax, [edi+4] );
	mov( [esi+8], eax );
	mov( eax, [edi+8] );
	mov( [esi+12], eax );
	mov( eax, [edi+12] );
	jmp bmux;
	
  setRight:
  	mov( dest, esi );
	mov( [edi], eax );
	mov( eax, [esi] );
	mov( [edi+4], eax );
	mov( eax, [esi+4] );
	mov( [edi+8], eax );
	mov( eax, [esi+8] );
	mov( [edi+12], eax );
	mov( eax, [esi+12] );
	
  bmux:
  	pop( edi );
	pop( esi );

end bigminUns;
	
	
	
procedure bigminInt( var dest:var; var left:var; var right:var );
begin bigminInt;

	push( esi );
	push( edi );
	mov( left, esi );
	mov( right, edi );
	
	mov( [esi+12], eax );
	cmp( eax, [edi+12] );
	jg setRight;
	jl setLeft;
	
	mov( [esi+8], eax );
	cmp( eax, [edi+8] );
	jg setRight;
	jl setLeft;
	
	mov( [esi+4], eax );
	cmp( eax, [edi+4] );
	jg setRight;
	jl setLeft;
	
	mov( [esi], eax );
	cmp( eax, [edi] );
	jg setRight;

  setLeft:
  	mov( dest, edi );
	mov( eax, [edi] );
	mov( [esi+4], eax );
	mov( eax, [edi+4] );
	mov( [esi+8], eax );
	mov( eax, [edi+8] );
	mov( [esi+12], eax );
	mov( eax, [edi+12] );
	jmp bmux;
	
  setRight:
  	mov( dest, esi );
	mov( [edi], eax );
	mov( eax, [esi] );
	mov( [edi+4], eax );
	mov( eax, [esi+4] );
	mov( [edi+8], eax );
	mov( eax, [esi+8] );
	mov( [edi+12], eax );
	mov( eax, [esi+12] );
	
  bmux:
  	pop( edi );
	pop( esi );

end bigminInt;
	




// NumToStr- Recursive routine called by UnsToStr and
//			 IntToStr to recursively convert a 128-bit
//			 unsigned value to a zero-terminated string.
//
//	ESI-	Points at the number to convert
//	ESI-	Points at the buffer where the chars go.

procedure NumToStr; @noframe;
static
	ten:dword := 10;
begin NumToStr;

	// 128/32 division algorithm:
	
	mov( [esi+3*4], eax );
	xor( edx, edx );
	div( ten );
	mov( eax, [esi+3*4] );
	
	mov( [esi+2*4], eax );
	div( ten );
	mov( eax, [esi+2*4] );
	
	mov( [esi+1*4], eax );
	div( ten );
	mov( eax, [esi+1*4] );
	
	mov( [esi+0*4], eax );
	div( ten );
	mov( eax, [esi+0*4] );
	
	or( [esi+1*4], eax );
	or( [esi+2*4], eax );
	or( [esi+3*4], eax );
	if( @nz ) then
	
		// If the division did not produce a zero quotient,
		// then save the remainder (current character) and
		// recursively call this routine until we get zero.
	
		push( edx );	// Preserve remainder.
		call NumToStr;
		pop( edx );
		
	endif;
	or( '0', dl );			// Convert remainder (0..9) to a char ('0'..'9')
	mov( dl, [edi] );		// Save away in buffer.
	inc( edi );				// Move on to the next position.
	mov( 0, (type byte [edi]) );	// Zero terminates string.
	ret();
	
end NumToStr;
	
	

// UnsToStr- Converts a 128-bit unsigned value to its
//			 string representation.

procedure UnsToStr( var buf:var; var unsval:var );
begin UnsToStr;

	push( edx );
	push( edi );
	push( esi );
	
	mov( buf, edi );
	mov( unsval, esi );
	call NumToStr;
	
	pop( esi );
	pop( edi );
	pop( edx );

end UnsToStr;


	
	

// IntToStr- Converts a 128-bit signed value to its
//			 string representation.

procedure IntToStr( var buf:var; var intval:var );
begin IntToStr;

	push( edx );
	push( edi );
	push( esi );
	
	mov( buf, edi );
	mov( intval, esi );
	
	// If the number is negative, output a '-' and then
	// negate the value so it is non-negative:
	
	if( (type int8 [esi+15]) < 0 ) then
	
		mov( '-', (type char [edi]));
		inc( edi );
		xor( eax, eax );
		sub( [esi], eax );
		mov( eax, [esi] );
		
		mov( 0, eax );
		sbb( [esi+1*4], eax );
		mov( eax, [esi+1*4] );
		
		mov( 0, eax );
		sbb( [esi+2*4], eax );
		mov( eax, [esi+2*4] );
		
		mov( 0, eax );
		sbb( [esi+3*4], eax );
		mov( eax, [esi+3*4] );
		
	endif;
		
	// Now do the unsigned conversion:
	
	call NumToStr;
	
	pop( esi );
	pop( edi );
	pop( edx );

end IntToStr;
				

/**************************************************************/
/*                                                            */
/* DecStrToInt-                                               */
/*                                                            */
/* After the lexer scans a string of numeric digits, it calls */
/* this function to convert them to an integer value.         */
/* This function sets the type and value of the destination   */
/* operand based on the size of the numeric value.            */
/* Note that the type is always an unsigned integer type.     */
/*                                                            */
/**************************************************************/

procedure DecStrToInt
( 
	PtrToStr	:dword;
	PtrToDest	:dword;
	PtrToType	:dword;
	PtrTopType	:dword
);
var
	Reslt	:dword[4];
	
	procedure MulReslt10; @noframe;
	begin MulReslt10;
	
		push( eax );
		push( ebx );
		
		shl( 1, ebp::Reslt[0*4] );
		rcl( 1, ebp::Reslt[1*4] );
		rcl( 1, ebp::Reslt[2*4] );
		rcl( 1, ebp::Reslt[3*4] );
		jc Overflow;
		
		mov( ebp::Reslt[0*4], eax );
		mov( ebp::Reslt[1*4], ebx );
		mov( ebp::Reslt[2*4], ecx );
		mov( ebp::Reslt[3*4], edx );
		
		shl( 1, eax );
		rcl( 1, ebx );
		rcl( 1, ecx );
		rcl( 1, edx );
		jc Overflow;
		
		shl( 1, eax );
		rcl( 1, ebx );
		rcl( 1, ecx );
		rcl( 1, edx );
		jc Overflow;
		
		add( eax, ebp::Reslt[0*4] );
		adc( ebx, ebp::Reslt[1*4] );
		adc( ecx, ebp::Reslt[2*4] );
		adc( edx, ebp::Reslt[3*4] );
		jc Overflow;
		
		pop( ebx );
		pop( eax );
		and( $f, eax );
		add( eax, ebp::Reslt[0*4] );
		adc( 0, ebp::Reslt[1*4] );
		adc( 0, ebp::Reslt[2*4] );
		adc( 0, ebp::Reslt[3*4] );
		jc Overflow2;
		ret();
		
	  Overflow2:
	  	push( eax );
		push( ebx );
	  Overflow:
	  	pop( ebx );
		pop( eax );
		HLAerr( "Decimal integer constant is too large" );
		ret();
		
	end MulReslt10;
	
begin DecStrToInt;

	push( ebx );
	push( ecx );
	push( edx );
	
	
	xor( eax, eax );
	mov( eax, Reslt[0*4] );
	mov( eax, Reslt[1*4] );
	mov( eax, Reslt[2*4] );
	mov( eax, Reslt[3*4] );
	
	mov( PtrToStr, ebx );
	jmp start;
	ForEachDigit:
		call MulReslt10;
		inc( ebx );
	  start:
		mov( [ebx], al );
		cmp( al, 0 );
		jne ForEachDigit;
	
	// Copy the data to the destination:
		
	mov( PtrToDest, ebx );
	mov( Reslt[0*4], eax );
	mov( eax, [ebx] );
	mov( Reslt[1*4], eax );
	mov( eax, [ebx+4] );
	mov( Reslt[2*4], eax );
	mov( eax, [ebx+8] );
	mov( Reslt[3*4], eax );
	mov( eax, [ebx+12] );
	
	// Set the type to one of uns8..uns128 depending on
	// size of the value:
	
	mov( PtrTopType, ebx );
	mov( PtrToType, eax );
	
	// Check for Uns128:
	
	mov( tUns128, (type byte [ebx]));
	mov( &uns128_ste, (type dword [eax]));
	cmp( Reslt[3*4], 0 );
	jne AllDone;
	cmp( Reslt[2*4], 0 );
	jne AllDone;
	
	// Check for Uns64:
	
	mov( tUns64, (type byte [ebx]));
	mov( &uns64_ste, (type dword [eax]));
	cmp( Reslt[1*4], 0 );
	jne AllDone;
	
	// Check for Uns32:
	
	mov( tUns32, (type byte [ebx]));
	mov( &uns32_ste, (type dword [eax]));
	cmp( (type word Reslt[2]), 0 );
	jne AllDone;
	
	
	// Check for Uns16:
	
	mov( tUns16, (type byte [ebx]));
	mov( &uns16_ste, (type dword [eax]));
	cmp( (type byte Reslt[1]), 0 );
	jne AllDone;
	
	// Must be Uns8:
	
	mov( tUns8, (type byte [ebx]));
	mov( &uns8_ste, (type dword [eax]));
	
	AllDone:
		pop( edx );
		pop( ecx );
		pop( ebx );
	
end DecStrToInt; 


/**************************************************************/
/*                                                            */
/* BinStrToInt-                                               */
/*                                                            */
/* After the lexer scans a string of binary digits, it calls  */
/* this function to convert them to an integer value.         */
/* This function sets the type and value of the destination   */
/* operand based on the size of the numeric value.            */
/* Note that the type is always an unsigned integer type.     */
/*                                                            */
/**************************************************************/


procedure BinStrToInt
( 
	PtrToStr	:dword;
	PtrToDest	:dword;
	PtrToType	:dword;
	PtrTopType	:dword
);
var
	Reslt	:dword[4];
	
begin BinStrToInt;

	push( ebx );

	xor( eax, eax );
	mov( eax, Reslt[0*4] );
	mov( eax, Reslt[1*4] );
	mov( eax, Reslt[2*4] );
	mov( eax, Reslt[3*4] );
	
	mov( PtrToStr, ebx );
	jmp start;
	ForEachDigit:
		shr( 1, al );
		rcl( 1, Reslt[0*4] );
		rcl( 1, Reslt[1*4] );
		rcl( 1, Reslt[2*4] );
		rcl( 1, Reslt[3*4] );
		jnc start;
		HLAerr( "Binary constant is too large" );
		
	  start:
		inc( ebx );			//1st time through skips '%'
		mov( [ebx], al );
		cmp( al, 0 );
		jne ForEachDigit;
	
	// Copy the data to the destination:
		
	mov( PtrToDest, ebx );
	mov( Reslt[0*4], eax );
	mov( eax, [ebx] );
	mov( Reslt[1*4], eax );
	mov( eax, [ebx+4] );
	mov( Reslt[2*4], eax );
	mov( eax, [ebx+8] );
	mov( Reslt[3*4], eax );
	mov( eax, [ebx+12] );
	
	// Set the type to one of uns8..uns128 depending on
	// size of the value:
	
	mov( PtrTopType, ebx );
	mov( PtrToType, eax );
	
	// Check for LWord:
	
	mov( tLWord, (type byte [ebx]));
	mov( &lword_ste, (type dword [eax]));
	cmp( Reslt[12], 0 );
	jne AllDone;
	cmp( (type word Reslt[10]), 0 );
	jne AllDone;
	
	// Check for TByte:
	
	mov( tTByte, (type byte [ebx]));
	mov( &tbyte_ste, (type dword [eax]));
	cmp( (type word Reslt[8]), 0 );
	jne AllDone;
	
	// Check for QWord:
	
	mov( tQWord, (type byte [ebx]));
	mov( &qword_ste, (type dword [eax]));
	cmp( Reslt[1*4], 0 );
	jne AllDone;
	
	// Check for DWord:
	
	mov( tDWord, (type byte [ebx]));
	mov( &dword_ste, (type dword [eax]));
	cmp( (type word Reslt[2]), 0 );
	jne AllDone;
	
	
	// Check for Word:
	
	mov( tWord, (type byte [ebx]));
	mov( &word_ste, (type dword [eax]));
	cmp( (type byte Reslt[1]), 0 );
	jne AllDone;
	
	// Must be Byte:
	
	mov( _tByte, (type byte [ebx]));
	mov( &byte_ste, (type dword [eax]));
	
	AllDone:
		pop( ebx );
	
end BinStrToInt; 







/**************************************************************/
/*                                                            */
/* HexStrToInt-                                               */
/*                                                            */
/* After the lexer scans a string of hex digits, it calls     */
/* this function to convert them to an integer value.         */
/* This function sets the type and value of the destination   */
/* operand based on the size of the numeric value.            */
/* Note that the type is always an unsigned integer type.     */
/*                                                            */
/**************************************************************/


procedure HexStrToInt
( 
	PtrToStr	:dword;
	PtrToDest	:dword;
	PtrToType	:dword;
	PtrTopType	:dword
);
var
	Reslt	:dword[4];
	
begin HexStrToInt;

	push( ebx );
	push( ecx );

	xor( eax, eax );
	mov( eax, Reslt[0*4] );
	mov( eax, Reslt[1*4] );
	mov( eax, Reslt[2*4] );
	mov( eax, Reslt[3*4] );
	
	mov( PtrToStr, ebx );
	jmp start;
	ForEachDigit:
		if( al > '9' ) then
			add( 9, al );
		endif;
		shl( 4, al );
		mov( 4, ecx );
		repeat
		
			shl( 1, al );
			rcl( 1, Reslt[0*4] );
			rcl( 1, Reslt[1*4] );
			rcl( 1, Reslt[2*4] );
			rcl( 1, Reslt[3*4] );
			if( @c ) then
			
				HLAerr( "Hexadecimal constant is too large" );
				
			endif;
			dec( ecx );
			
		until( @z );
		
	  start:
		inc( ebx );			//1st time through skips '$'
		mov( [ebx], al );
		cmp( al, 0 );
		jne ForEachDigit;
	
	// Copy the data to the destination:
		
	mov( PtrToDest, ebx );
	mov( Reslt[0*4], eax );
	mov( eax, [ebx] );
	mov( Reslt[1*4], eax );
	mov( eax, [ebx+4] );
	mov( Reslt[2*4], eax );
	mov( eax, [ebx+8] );
	mov( Reslt[3*4], eax );
	mov( eax, [ebx+12] );
	
	// Set the type to one of byte..lword depending on
	// size of the value:
	
	mov( PtrTopType, ebx );
	mov( PtrToType, eax );
	
	// Check for LWord:
	
	mov( tLWord, (type byte [ebx]));
	mov( &lword_ste, (type dword [eax]));
	cmp( Reslt[12], 0 );
	jne AllDone;
	cmp( (type word Reslt[10]), 0 );
	jne AllDone;
	
	// Check for TByte:
	
	mov( tTByte, (type byte [ebx]));
	mov( &tbyte_ste, (type dword [eax]));
	cmp( (type word Reslt[8]), 0 );
	jne AllDone;
	
	// Check for QWord:
	
	mov( tQWord, (type byte [ebx]));
	mov( &qword_ste, (type dword [eax]));
	cmp( Reslt[1*4], 0 );
	jne AllDone;
	
	// Check for DWord:
	
	mov( tDWord, (type byte [ebx]));
	mov( &dword_ste, (type dword [eax]));
	cmp( (type word Reslt[2]), 0 );
	jne AllDone;
	
	
	// Check for Word:
	
	mov( tWord, (type byte [ebx]));
	mov( &word_ste, (type dword [eax]));
	cmp( (type byte Reslt[1]), 0 );
	jne AllDone;
	
	// Must be Byte:
	
	mov( _tByte, (type byte [ebx]));
	mov( &byte_ste, (type dword [eax]));
	
	AllDone:
		pop( ecx );
		pop( ebx );
	
end HexStrToInt; 

	










//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
///////////////////////                                 //////////////////////
/////////////////////// Floating Point Support Routines //////////////////////
///////////////////////                                 //////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////


// The following convert data from real80 to real64 or real32.
// Could really have let InRange do this work.  Oh Well...
   
procedure real80to64( var data:var );
begin real80to64;	

	mov( data, eax );
	fld( (type real80 [eax]) );
	fstp( (type real64 [eax]) );
	mov( 0, (type dword [eax+8]));
	mov( 0, (type dword [eax+12]));
	
end	real80to64;
	
procedure real80to32( var data:var );
begin real80to32;	

	mov( data, eax );
	fld( (type real80 [eax]) );
	fstp( (type real32 [eax]) );
	mov( 0, (type dword [eax+4]));
	mov( 0, (type dword [eax+8]));
	mov( 0, (type dword [eax+12]));
	
end	real80to32;




// unsf80-
//
//	Translates the uns64 parameter to an 80-bit fp value and
//	stores this into the destination variable.  Note: really
//	only valid for up to 63-bit unsigned values.

procedure unsf80(  var src:var; var f:real80 ); @nodisplay;
begin unsf80;

	mov( src, eax );
	fild( (type qword [eax]) );
	mov( f, eax );
	fstp( (type real80 [eax]) );
	
end unsf80;
	
	

// f80int-
//
//	Converts an 80-bit real to an integer via truncation.


procedure f80int( src:real80_t; var dest:var ); @nodisplay;
var
	fcw16: 		word[2];
	
static
	fcw: word := $fff;
	
begin f80int;
	
	fstcw( fcw16 );
	fldcw( fcw );
	
	fld( src.r );
	mov( dest, eax );
	fistp( (type qword [eax]) );	// Convert with truncation.
	
	fldcw( fcw16 );					// Restore original rounding mode.
	
end f80int;
	

// fadd80, fsub80, fmul80, fdiv80-
//
//	This do the obvious operations.
//	Computation is f = l op r;

procedure fadd80(  r:real80_t; l:real80_t; var f:real80 ); @noframe; @nodisplay;
begin fadd80;

	push( ebp );
	mov( esp, ebp );
	fld( l.r );
	fld( r.r );
	faddp();
	mov( f, eax );
	fstp( (type real80 [eax]) );
	pop( ebp );
	ret();
	
end fadd80;
	

procedure fsub80(  r:real80_t; l:real80_t; var f:real80 ); @noframe; @nodisplay;
begin fsub80;

	push( ebp );
	mov( esp, ebp );
	fld( l.r );
	fld( r.r );
	fsubp();
	mov( f, eax );
	fstp( (type real80 [eax]) );
	pop( ebp );
	ret();
	
end fsub80;

procedure fmul80(  r:real80_t; l:real80_t; var f:real80 ); @noframe; @nodisplay;
begin fmul80;

	push( ebp );
	mov( esp, ebp );
	fld( l.r );
	fld( r.r );
	fmulp();
	mov( f, eax );
	fstp( (type real80 [eax]) );
	pop( ebp );
	ret();
	
end fmul80;

procedure fdiv80(  r:real80_t; l:real80_t; var f:real80 ); @noframe; @nodisplay;
begin fdiv80;

	push( ebp );
	mov( esp, ebp );
	fld( l.r );
	fld( r.r );
	fdivp();
	mov( f, eax );
	fstp( (type real80 [eax]) );
	pop( ebp );
	ret();
	
end fdiv80;


// fneg80-
//
//	Computes f = -l;

procedure fneg80(  l:real80_t; var f:real80 ); @noframe; @nodisplay;
begin fneg80;

	push( ebp );
	mov( esp, ebp );
	fld( l.r );
	fchs();
	mov( f, eax );
	fstp( (type real80 [eax]) );
	pop( ebp );
	ret();
	
end fneg80;
	

// fabs80-
//
//	Computes f = abs( l );

procedure fabs80(  l:real80_t; var f:real80 ); @noframe; @nodisplay;
begin fabs80;

	push( ebp );
	mov( esp, ebp );
	fld( l.r );
	fabs();
	mov( f, eax );
	fstp( (type real80 [eax]) );
	pop( ebp );
	ret();
	
end fabs80;
	

// fmax80, fmin80-
//
//	Compute the maximum and minimum of the l and r operands, and
//  return the result in f.

procedure fmax80( r:real80_t; l:real80_t; var f:real80 ); @nodisplay; @noframe;
begin fmax80;

	push( ebp );
	mov( esp, ebp );
	
	fld( l.r );
	fld( r.r );
	fcom();
	fstsw( ax );
	sahf();
	mov( f, eax );
	if( @nb ) then
	
		fstp( r.r );					// Just pop r off the stack.
		fstp( (type real80 [eax]) );	// Max is l, store into f.
		
	else
	
		fstp( (type real80 [eax]) );	// r is max, store it into f.
		fstp( l.r );					// just pop l off the stack.
		
	endif;
	
	pop( ebp );
	ret();
	
end fmax80;	
	
	
procedure fmin80( r:real80_t; l:real80_t; var f:real80 ); @nodisplay; @noframe;
begin fmin80;

	push( ebp );
	mov( esp, ebp );
	
	fld( l.r );
	fld( r.r );
	fcom();
	fstsw( ax );
	sahf();
	mov( f, eax );
	if( @b ) then
	
		fstp( r.r );					// Just pop r off the stack.
		fstp( (type real80 [eax]) );	// Min is l, store into f.
		
	else
	
		fstp( (type real80 [eax]) );	// r is min, store it into f.
		fstp( l.r );					// just pop l off the stack.
		
	endif;
	
	pop( ebp );
	ret();
	
end fmin80;	
	


// feq80..fge80-
//
//	These functions compare their operands and return
//	true/false in EAX to denote the result of the comparison.

procedure feq80 ( r:real80_t; l:real80_t ); @nodisplay; @noframe;
begin feq80;

	push( ebp );
	mov( esp, ebp );
	
	fld( r.r );
	fld( l.r );
	fcompp();
	fstsw( ax );
	sahf();
	mov( 0, eax );
	sete( al );	
	pop( ebp );
	ret();
	
end feq80;

procedure fne80 ( r:real80_t; l:real80_t ); @nodisplay; @noframe;
begin fne80;

	push( ebp );
	mov( esp, ebp );
	
	fld( r.r );
	fld( l.r );
	fcompp();
	fstsw( ax );
	sahf();
	mov( 0, eax );
	setne( al );	
	pop( ebp );
	ret();
	
end fne80;

procedure flt80 ( r:real80_t; l:real80_t ); @nodisplay; @noframe;
begin flt80;

	push( ebp );
	mov( esp, ebp );
	
	fld( r.r );
	fld( l.r );
	fcompp();
	fstsw( ax );
	sahf();
	mov( 0, eax );
	setb( al );	
	pop( ebp );
	ret();
	
end flt80;

procedure fle80 ( r:real80_t; l:real80_t ); @nodisplay; @noframe;
begin fle80;

	push( ebp );
	mov( esp, ebp );
	
	fld( r.r );
	fld( l.r );
	fcompp();
	fstsw( ax );
	sahf();
	mov( 0, eax );
	setbe( al );	
	pop( ebp );
	ret();
	
end fle80;

procedure fgt80 ( r:real80_t; l:real80_t ); @nodisplay; @noframe;
begin fgt80;

	push( ebp );
	mov( esp, ebp );
	
	fld( r.r );
	fld( l.r );
	fcompp();
	fstsw( ax );
	sahf();
	mov( 0, eax );
	seta( al );	
	pop( ebp );
	ret();
	
end fgt80;

procedure fge80 ( r:real80_t; l:real80_t ); @nodisplay; @noframe;
begin fge80;

	push( ebp );
	mov( esp, ebp );
	
	fld( r.r );
	fld( l.r );
	fcompp();
	fstsw( ax );
	sahf();
	mov( 0, eax );
	setae( al );	
	pop( ebp );
	ret();
	
end fge80;


// Standard real-valued functions:
//
//	ceil80-		Computes the smallest integer >= the src operand.
//	floor80-	Computes the largest integer <= the src operand.
//	cos80-		Computes the cosine of the operand (in radians).
//	sin80-		Computes the sine of the operand (in radians).
//	tan80-		Computes the tangent of the operand (in radians).
//	log80-		Computes the base-e log of the operand.
//	log8010-	Computes the base-10 log of the operand.
//	sqrt80-		Computes the square root of the operand.

procedure ceil80( src:real80_t; var dest:real80 ); @nodisplay; @noframe;
static
	fcwSave:	word;
	fcw:		word;
	
begin ceil80;

	push( ebp );
	mov( esp, ebp );
	
	fstcw( fcwSave );
	mov( fcwSave, fcw );
	mov( $f7f, fcw );
	fldcw( fcw );
	
	mov( (type word src[8]), ax );
	and( $7fff, ax );
	if( ax < 16383 ) then
	
		// The exponent is negative.  Therefore, the
		// result is zero if the value is zero or negative,
		// it's one if the value is positive.
		
		test( $80, (type byte src[9] ));
		if( @s ) then
		
			fldz();
			
		else
		
			cmp( (type dword src), 0 );
			jnz IsOne;
			cmp( (type dword src[4]), 0 );
			jnz IsOne;
			cmp( (type word src[8]), 0 );
			jnz IsOne;
			
				fldz();
				jmp WasZero;
				
			IsOne:
				fld1();
				
			WasZero:
			
		endif;
		
	else 
	
		// The exponent is positive and we
		// might have a fractional part.
		//
		//	To determine the ceiling, figure out
		// whether the value has a fractional component.
		// (is the integer component equal to the whole value?)
		// If not, then add one to the integer value if it is positive.
		
		fld( src.r );
		frndint();
		fld( src.r );
		fcomp();
		fstsw( ax );
		sahf();
		if( @nz ) then
		
			// If the number is negative, then the
			// truncation operation has already produced ceil.
			
			if( (type int8 src[9]) >= 0 ) then
			
				fld1();
				faddp();
				
			endif;
			
		endif;
	
	endif;
		
	mov( dest, eax );
	fstp( (type real80 [eax]) );
	
	fldcw( fcwSave );
	pop( ebp );
	ret();
	
end ceil80;

 
procedure floor80( src:real80_t; var dest:real80 ); @nodisplay; @noframe;
static
	fcwSave:	word;
	fcw:		word;
	
begin floor80;

	push( ebp );
	mov( esp, ebp );
	
	fstcw( fcwSave );
	mov( fcwSave, fcw );
	or( $f7f, fcw );
	fldcw( fcw );
	
	mov( (type word src[8]), ax );
	and( $7fff, ax );
	if( ax < 16383 ) then
	
		// The exponent is negative.  Therefore, the
		// result is zero.
		
		fldz();

	else 
	
		// The exponent is positive and we
		// might have a fractional part.
		//
		//	To determine the floor, figure out
		// whether the value has a fractional component.
		// (is the integer component equal to the whole value?)
		// If not, then subtract one from the integer value if it is negative.
		
		fld( src.r );
		frndint();
		fld( src.r );
		fcomp();
		fstsw( ax );
		sahf();
		if( @nz ) then
		
			// If the number is positive, then the
			// truncation operation has already produced floor.
			
			if( (type int8 src[9]) < 0 ) then
			
				fld1();
				fsubp();
				
			endif;
			
		endif;
	
	endif;
		
	mov( dest, eax );
	fstp( (type real80 [eax]) );
	
	fldcw( fcwSave );
	pop( ebp );
	ret();
	
end floor80;

 

 
procedure cos80( src:real80_t; var dest:real80 ); @nodisplay; @noframe; 
begin cos80;

	push( ebp );
	mov( esp, ebp );
	
	fld( src.r );
	fcos();
	mov( dest, eax );
	fstp( (type real80 [eax]) );
	
	pop( ebp );
	ret();
	
end cos80;

 
procedure sin80( src:real80_t; var dest:real80 ); @nodisplay; @noframe; 
begin sin80;

	push( ebp );
	mov( esp, ebp );
	
	fld( src.r );
	fsin();
	mov( dest, eax );
	fstp( (type real80 [eax]) );
	
	pop( ebp );
	ret();
	
end sin80;

 
procedure tan80( src:real80_t; var dest:real80 ); @nodisplay; @noframe; 
begin tan80;

	push( ebp );
	mov( esp, ebp );
	
	fld( src.r );
	fsincos();
	fdivp();
	mov( dest, eax );
	fstp( (type real80 [eax]) );
	
	pop( ebp );
	ret();
	
end tan80;

 
procedure log80( src:real80_t; var dest:real80 ); @nodisplay; @noframe; 
begin log80;

	push( ebp );
	mov( esp, ebp );
	

	fld1();
	fld( src.r );
	fyl2x();		// Compute 1*lg(x).
	fldl2e();		// Load lg(e).
	fdivp();			// Compute lg(x)/lg(e).
	mov( dest, eax );
	fstp( (type real80 [eax]) );
	
	pop( ebp );
	ret();
	
end log80;

 
procedure log1080( src:real80_t; var dest:real80 ); @nodisplay; @noframe;
begin log1080;

	push( ebp );
	mov( esp, ebp );
	
	fld1();
	fld( src.r );
	fyl2x();		// Compute 1*lg(x).
	fldl2t();		// Load lg(10).
	fdivp();		// Compute lg(x)/lg(10).
	mov( dest, eax );
	fstp( (type real80 [eax]) );

	pop( ebp );
	ret();
	
end log1080;

 
procedure sqrt80( src:real80_t; var dest:real80 ); @nodisplay; @noframe; 
begin sqrt80;

	push( ebp );
	mov( esp, ebp );
	
	fld( src.r );
	fsqrt();
	mov( dest, eax );
	fstp( (type real80 [eax]) );
	pop( ebp );
	ret();
	
end sqrt80;



procedure exp80( src:real80_t; var dest:real80 ); @nodisplay; @noframe;
static
	SaveCW:		word;
	MaskedCW:	word;
	 
begin exp80;

	push( ebp );
	mov( esp, ebp );
	
	fld( src.r );
	fldl2e();		// Put lg(e) onto the stack.
	fmulp(); 		// Compute x*lg(e).
	
	// Compute 2**x:
	
	fstcw( SaveCW );

	// Modify the control word to truncate when rounding.

	mov( $f7f, MaskedCW );

	fld( st0 );			// Duplicate tos.
	frndint();			// Compute integer portion.

	fxch();				// Swap whole and int values.
	fsub( st1, st0 );	// Compute fractional part.

	f2xm1();			// Compute 2**frac(x)-1.

	fld1();
	faddp();			// Compute 2**frac(x).

	fxch();				// Get integer portion.
	fld1();				// Compute 1*2**int(x).

	fscale();
	fstp( st1 );		// Remove st(1) (which is 1).
			  
	fmulp();			// Compute 2**int(x) * 2**frac(x).

	fldcw( SaveCW );	// Restore rounding mode.
	
	pop( ebp );
	ret();
	
end exp80;






 
	

// atold-
//
//	Converts a string to a floating point value.
//
//	"s" contains the string representation of the FP value, this function
// converts it to FP and stores the result in dest.

procedure atold( s:string; var dest:real80 ); @nodisplay; @noalignstack; @noframe;
const
	sign:		text := "cl";
	expSign:	text := "ch";
	
var
	DigitStr:	char[20];
	BCDValue:	tbyte;
	fpresult:	real80;
	
static


	PotTbl:		real80[ 14 ]; @nostorage;

						tbyte	$7525C46052028A20979B;	// 1.0e+4096,
						tbyte	$5A929E8B3B5DC53D5DE5;	// 1.0e+2048,
						tbyte	$4D48C976758681750C17;	// 1.0e+1024,
						tbyte	$46A3E319A0AEA60E91C7;	// 1.0e+512,
						tbyte	$4351AA7EEBFB9DF9DE8E;	// 1.0e+256,
						tbyte	$41A893BA47C980E98CE0;	// 1.0e+128,
						tbyte	$40D3C2781F49FFCFA6D5;	// 1.0e+64,
						tbyte	$40699DC5ADA82B70B59E;	// 1.0e+32,
						tbyte	$40348E1BC9BF04000000;	// 1.0e+16,
						tbyte	$4019BEBC200000000000;	// 1.0e+8,
						tbyte	$400C9C40000000000000;	// 1.0e+4,
						tbyte	$4005C800000000000000;	// 1.0e+2,
						tbyte	$4002A000000000000000;	// 1.0e+1,
						tbyte	$3FFF8000000000000000;	// 1.0e+0
							


	Delimiters:	cset :=	
		{
			#0, #9, #10, #13, 
			' ', 
			',',
			';',
			':'
		};




	

	#macro NextChar;

		xor( eax, eax );
		repeat
		
			inc( esi );
			mov( [esi], al );
			
		until( al <> '_' );
		
	#endmacro;

	#macro CurChar;

		dec( esi );
		xor( eax, eax );
		repeat
		
			inc( esi );
			mov( [esi], al );
			
		until( al <> '_' );
		
	#endmacro;

	// TstDelimiter- Sets carry flag if character in AL is a legal
	//				 delimiter char (member of above set).

	#macro TstDelimiter;

		if( eax >= $80 ) then  // If it's not ASCII, it's an error.

			clc();
			
		else

			bt( eax, (type dword Delimiters ));

		endif;
		
	#endmacro;

	
	procedure DigitsToRightOfDecPt; @nodisplay; @noframe;
	begin DigitsToRightOfDecPt;
	
		dec( esi );
		DigitLoop:
		
			NextChar;
			sub( '0', al );
			cmp( al, 10 );
			jae EndDigits;
			
			dec( edx );
 		
			// If we've not yet processed 18 significant
			// digits, save away the current digit.
			
			test( ebx, ebx );
			jz DigitLoop;
			mov( al, ebp::DigitStr[ ebx ]);
			dec( ebx );
			jmp DigitLoop;
				
		
		EndDigits:
		ret();
		
	end DigitsToRightOfDecPt;



	
	
	#macro Merge4( DSOffset, BCDOffset );
	
		mov( DigitStr[ DSOffset+1 ], al );
		shl( 4, al );
		or(	DigitStr[ DSOffset ], al );
		mov( al, (type byte BCDValue[ BCDOffset ]) );
		
	#endmacro;



begin atold;

	push( ebp );
	mov( esp, ebp );
	sub( _vars_, esp );
	
	
	finit();

	push( eax );
	push( ebx );
	push( ecx );
	push( edx );
	push( esi );
	mov( s, esi );
	
		
	// Zero out the DigitStr array.
	
	xor( eax, eax );
	mov( eax, (type dword DigitStr ));
	mov( eax, (type dword DigitStr[4] ));
	mov( eax, (type dword DigitStr[8] ));
	mov( eax, (type dword DigitStr[12] ));
	mov( eax, (type dword DigitStr[16] ));
	
	mov( eax, (type dword BCDValue ));
	mov( eax, (type dword BCDValue[4] ));
	mov( ax, (type word BCDValue[8] ));
	
	// Skip over any leading delimiter characters in the sequence.
	
	dec( esi );
	whileDelimLoop:
	
		NextChar;
		TstDelimiter;
		jc whileDelimLoop;
	
	
	
	// Check for + or -
	
	mov( false, sign );		// Assume the value is positive.
	if( al = '-' ) then
	
		NextChar;			// Skip over "-".
		mov( true, sign );	// If we've got a "-", set the sign flag.
		
	elseif( al = '+' ) then
		
		NextChar;			// Skip over the "+".
			
	endif;
	
	// Initialize edx with -18 since we have to account
	// for BCD conversion (which generates a number *10^18 by
	// default).
	
	mov( -18, edx );
	
	// Initialize ebx with 18, the number of significant
	// digits left to process and also the index into the
	// DigitStr array.
	
	mov( 18, ebx );
	
	// At this point we're beyond any leading sign character.
	// Therefore, the next character must be a decimal digit
	// or a decimal point.

	push( esi );		// Save so we can look ahead one digit.
	if( al = '.' ) then

		// If the first character is a decimal point, then the
		// second character needs to be a decimal digit.
			
		NextChar;
		
	endif;
	cmp( al, '0' );
	jb Failed;
	cmp( al, '9' );
	ja Failed;

	pop( esi );			// Okay, go back to our original character
	CurChar;			// since we've verified that we have a digit.
	

	// Eliminate any leading zeros (they do not affect the value or
	// the number of significant digits).
	
	while( al = '0' ) do
	
		NextChar;
		
	endwhile;
	
	
	// If we're looking at a decimal point, we need to get rid of the
	// zeros immediately after the decimal point since they don't
	// count as significant digits.  Unlike zeros before the decimal
	// point, however, these zeros do affect the number's value as
	// we must decrement the current exponent for each such zero.
	
	if( al = '.' ) then
	
		inc( edx );
		repeat
		
			dec( edx );
			NextChar;
			
		until( al <> '0' );		
		
		
	else
	
		// If we didn't encounter a decimal point after removing leading
		// zeros, then we've got a sequence of digits before a decimal
		// point.  Process those digits here.

		while
		(#{
			sub( '0', al );
			cmp( al, 10 );
			jae false;
		}#) do

			// Each digit to the left of the decimal point increases
			// the number by an additional power of ten.  Deal with
			// that here.
			
			inc( edx );	

			// Save all the significant digits, but ignore any digits
			// beyond the 18th digit.
			
			if( ebx <> 0 ) then
			
				mov( al, DigitStr[ ebx ]);
				dec( ebx );
				
			endif;
			NextChar;
			
		endwhile;
		if( al = ( byte('.') - byte('0') ) ) then
		
			NextChar;		// Skip over decimal point.
						
		endif;
		
	endif;
	
	
	
	
	

	// Okay, process any digits to the right of the decimal point.
	
	CurChar;
	while
	(#{
		sub( '0', al );
		cmp( al, 10 );
		jae false;
	}#) do
	
		if( ebx <> 0 ) then
		
			mov( al, DigitStr[ ebx ]);
			dec( ebx );
			
		endif;
		NextChar;
		
	endwhile;		
		
	// At this point, we've finished processing the mantissa.
	// Now see if there is an exponent we need to deal with.
	
	CurChar;
	if
	(#{
		cmp( al, 'e' );
		je true;
		cmp( al, 'E' );
		jne false;
	}#) then
		
	
		NextChar;				// Skip the "E".
		cmp( al, '-' );
		sete( expSign );
		if
		(#{
			cmp( al, '+' );
			je true;
			cmp( al, '-' );
			jne false;
		}#) then
		
			NextChar;			// Skip sign character.
			
		endif;
		
		// Okay, we're past the "E" and the optional sign at this
		// point.  We must have at least one decimal digit.
		
		sub( '0', al );
		cmp( al, 10 );
		jae Failed;
		
		xor( ebx, ebx );		// Compute exponent value in ebx.
		ExpLoop:
		
			movzx( (type byte [esi]), eax );
			sub( '0', al );
			cmp( al, 10 );
			jae	ExpDone;
			
			intmul( 10, ebx );
			add( eax, ebx );
			inc( esi );
			jmp ExpLoop;
			
		ExpDone:
		
		// If the exponent was negative, negate our computed result.
		
		if( expSign = true ) then
		
			neg( ebx );
			
		endif;

		// Add in the BCD adjustment (remember, values in DigitStr, when
		// loaded into the FPU, are multiplied by 10^18 by default.
		// The value in edx adjusts for this).
		
		add( ebx, edx );
		
	endif;
		
	// verify that the exponent is between -4930..+4930 (which
	// is the maximum dynamic range for an 80-bit FP value).

	cmp( edx, 4930 );
	jg Failed;
	cmp( edx, -4930 );
	jl Failed;
	
	// Now convert the DigitStr variable (unpacked BCD) to a packed
	// BCD value.
	
	Merge4( 17, 8 );
	Merge4( 15, 7 );
	Merge4( 13, 6 );
	Merge4( 11, 5 );
	Merge4( 9, 4 );
	Merge4( 7, 3 );
	Merge4( 5, 2 );
	Merge4( 3, 1 )
	Merge4( 1, 0 );


	fbld( BCDValue );
	
	
	
	// Okay, we've got the mantissa into the FPU.  Now multiply the
	// Mantissa by 10 raise the the value of the computed exponent
	// (currently in edx).
	//
	// This code uses power of 10 tables to help make the computation
	// a little more accurate.
	//
	// We want to determine which power of ten is just less than the
	// value of our exponent.  The powers of ten we are checking are
	// 10**4096, 10**2048, 10**1024, 10**512, etc.  A slick way to
	// do this check is by shifting the bits in the exponent
	// to the left.  Bit #12 is the 4096 bit.  So if this bit is set,
	// our exponent is >= 10**4096.  If not, check the next bit down
	// to see if our exponent >= 10**2048, etc.

	mov( -10, ebx );	// Initial index into power of ten table.
	if( (type int32 edx) < 0 ) then
	
		// Handle negative exponents here.
		
		neg( edx );
		shl( 19, edx );		// Bits 0..12 -> 19..31
		while( edx <> 0 ) do
		
			add( 10, ebx );
		
			shl( 1, edx );
			if( @c ) then
			
				fld( PotTbl[ ebx ]);
				fdivp();

			endif;
			
		endwhile;

	else
	
		// Handle positive exponents here.
		
		shl( 19, edx );		// Bits 0..12 -> 19..31.
		while( edx <> 0 ) do
		
			add( 10, ebx );
			if
			(#{
				shl( 1, edx );
				jnc false;
			}#) then
			
				fld( PotTbl[ ebx ]);
				fmulp();
				
			endif;
			
		endwhile;
		
	endif;

	
	// If the mantissa was negative, negate the result down here.

	if( sign = true ) then
	
		fchs();
		
	endif;

	jmp GoodEndOfFP;

	Failed:
		fldz();

	GoodEndOfFP:

	mov( dest, eax );
	fstp( (type real80 [eax])  );


ExitAtold:	
	pop( esi );			
	pop( edx );
	pop( ecx );
	pop( ebx );
	pop( eax );
	mov( ebp, esp );
	pop( ebp );
	ret();

end atold;



procedure htoa; @nodisplay; @noframe;
begin htoa;

	push( eax );
	mov( al, ah );
	shr( 4, al );
	or( '0', al );
	stosb();
	
	mov( ah, al );
	and( $f, al );
	or( '0', al );
	stosb();
	pop( eax );
	ret();
	
end htoa;
	


procedure FPDigits; @noframe; @nodisplay;

static

	TenTo17	:	Real80; @nostorage;
					tbyte $4037B1A2BC2EC5000000;	// 1.0e+17;
					
	TenTo16	:	Real80; @nostorage;
					tbyte $40348E1BC9BF04000000;	// 1.0e+16;
					
	OneE10:		Real80; @nostorage;
					tbyte $40209502F90000000000;	// 1.0e+10;
					
	OneEm10:	Real80; @nostorage;
					tbyte $3FDDDBE6FECEBDEDD5BF;	// 1.0e-10;
					
	Ten:		Real80; @nostorage;
					tbyte $4002A000000000000000;	// 10.0;
					
	FiveEm18:	real80; @nostorage;
					tbyte $3FC5B877AA3236A4B464;	// 5e-18
	
	temp		:real64;			

begin FPDigits;

	/*
	** Special case if the number is zero.
	*/
	
	fldz();
	fcomp();
	fstsw( ax );
	sahf();
	if( @z ) then

		/*
		** The number is zero, output it as a special case.
		*/
		
		mov( $30303030, eax );	// "0000"
		stosd();
		stosd();
		stosd();
		stosd();
		stosd();
		stosd();
		xor( edx, edx );		// Return an exponent of zero.
		mov( ' ', bl );			// Sign is positive.
		
	else


		/*
		** If the number is not zero, then fix the sign of the value.
		*/

		mov( ' ', bl );				// Assume the exponent is positive.		   
		if( @a ) then				// Flags still set from sahf above.
		
			fabs();					// Deal only with positive numbers.
			mov( '-', bl );			// Set the sign return result.
			
		endif;

		/*
		** Get the number between one and ten so we can figure out what the
		** exponent is.  Begin by checking to see if we have a positive
		** or negative exponent.
		*/
		
		xor( edx, edx );			// Initialize exponent to zero.
		fld1();
		fcomp();
		fstsw( ax );
		sahf();
		if( @ae ) then				// If 1.0 >= x

			/*
			** We've got a value between zero and one, exclusive, at this point.
			** That means this number has a negative exponent.  Multiply the
			** number by an appropriate power of ten until we get it in the
			** range 1 <= x < 10.
			**
			**	Do this in two phases: First, reduce by 1E10 (for performance)
			** and then do the final cleanup by reducing by 10.
			** (Note: 1E10 is the largest power of 10 we can represent
			** exactly.  Anything larger tends to produce inaccurate results
			** and leads to the generation of bad output for certain values.)
			*/
			
			forever

				fld( OneEm10 );
				fcomp();
				fstsw( ax );
				sahf();
				breakif( @be );
				
				// Multiply value by 1e+10.
				
				sub( 10, edx );
				fld( OneE10 );
				fmulp();
					
			endfor;
			forever
			
				fld1();
				fcomp();
				fstsw( ax );
				sahf();
				breakif( @be );
				
				// Multiply value by 10.
				
				dec( edx );
				fld( Ten );
				fmulp();
					
			endfor;

			// Because we've done some serious arithmetic up to this
			// point, we need to round off the value in the last digit
			// position.
			
			fld( FiveEm18 );
			faddp();
			
			// The value may now be ten or greater, adjust for that:
			
			fld( Ten );
			fcomp();
			fstsw( ax );
			sahf();
			if( @be ) then
			
				fld( Ten );
				fdivp();
				inc( edx );
			
			endif;
			
		else	

			/*
			** At this point, we've got a number that is one or greater.
			** Our task is to get the value between one and ten.
			** Note that if we fell through from the above code, then
			** we may have generated a number in the range 1..1e10.
			**
			**	As above, for performance reasons we do this in two phases.
			*/

			forever

				fld( OneE10 );
				fcomp();
				fstsw( ax );
				sahf();
				breakif( @a );
				


				add( 10, edx );
				fld( OneE10 );
				fdivp();
					
			endfor;
			
			forever

				fld( Ten );
				fcomp();
				fstsw( ax );
				sahf();
				breakif( @a );

				inc( edx );
				fld( Ten );
				fdivp();
					
			endfor;
			
			
		endif;
			
				
		
		
		/*
		** Okay, at this point the number is in the range 1 <= x < 10,
		** Let's multiply it by 1e+17 to put the most sigificant digit
		** into the 18th print position.  Then convert the result to
		** a BCD value and store away in memory.
		*/

		fld( st0 );			// Duplicate in case of error.
		sub( 20, esp );		// Make room for BCD result.
		fld( TenTo17 );
		fmulp();
		fbstp( (type tbyte [esp]) );

		// In some rare cases, round off error can lead to
		// a value (above) that was not exactly in the range
		// 1 <= x < 10.  In some cases, the result may be
		// sufficiently close to 10 so as to create a problem
		// for the fbstp instruction above.  By checking the
		// H.O. byte of the BCD result we can determine if
		// this has happened.  if so, we divide by ten and
		// recalculate.
		//
		//	Note that the original (pre-fbstp) value is in ST0.
		 
		if( (type byte [esp+9]) > $99 ) then
		
			// We had round-off error in the calculations above.
			// adjust for that here.
			
			fld( TenTo16 );			// 1e17 / 10.
			fmulp();
			fbstp( (type tbyte [esp]));
			inc( edx );
			
		else

			// If the translation was okay, just pop the old
			// value off the FPU stack.
			
			fstp( st0 );
			
		endif;
			


		
		/*
		** The data on the stack contains 18 BCD digits.  Convert these
		** to ASCII characters and store them at the destination location
		** pointed at by edi.
		*/
		
		mov( 8, ecx );
		repeat
		
			mov( [esp+ecx], al );
			call( htoa );
			dec( ecx );
			
		until( (type int32 ecx) < 0 );
		
		add( 20, esp );			// Remove BCD data from stack.
		
	endif;
	mov( edx, eax );		// Return exponent in EAX.
	ret();
		
		
end FPDigits;




procedure e80Str( r80:real80_t; buffer:dword ); @nodisplay; @noframe;

static
	Digits:		byte[ 32 ];
	Exponent:	int32;
	Sign:		char;

begin e80Str;

	push( ebp );
	mov( esp, ebp );
	
	pushfd();
	pushad();
	cld();

	finit();
	if
	(#{
		cmp( (type dword r80[6]), 0 );
		jne false;
		cmp( (type dword r80[2]), 0 );
		jne false;
		mov( (type word r80), ax );
		and( $FFF0, ax );
		jne false;
	}#) then
		
		// We've got a number that is very close to zero.
		// Just round it down to zero to prevent any problems.
		
		mov( buffer, ebx );
		mov( '0', (type char [ebx]) );
		mov( '.', (type char [ebx+1]) );
		mov( '0', (type char [ebx+2]) );
		mov( #0, (type char [ebx+3]) );
	
	else	// We've got a number that is greater than zero.
	
		/*
		** Do the conversion.
		*/

		fld( r80.r );				// Put FP number on FPU stack.
		lea( edi, Digits );			// Store result string here.
		call( FPDigits );			// Convert r80 to digit string.
		mov( eax, Exponent );		// Save away exponent result.
		mov( bl, Sign );			// Save mantissa sign character.


		/*
		** Okay, emit the string at this point.  This is pretty easy
		** since all we really need to do is copy data from the
		** digits array and add an exponent (plus a few other simple chars).
		*/
		
		
		mov( buffer, edi );
		xor( edx, edx );		// Count output chars here.
		mov( Sign, al );
		if( al <> '-' ) then
		
			mov( ' ', al );
			
		endif;
		
		stosb();
		
		// Output the first character and a following decimal point
		// if there are more than two mantissa digits to output.
		
		mov( Digits, al );
		stosb();
		mov( '.', al );
		stosb();
		
		// Output the remaining mantissa digits:
		
		mov( 17, ecx );
		lea( esi, Digits[1] );
		rep.movsb();
		
		// Output the exponent:
		
		mov( 'e', al );
		stosb();
		mov( '+', al );
		if( Exponent < 0 ) then
		
			mov( '-', al );
			neg( Exponent );
						
		endif;
		stosb();

		mov( Exponent, eax );
		xor( edx, edx );
		mov( 1000, ebx );
		div( ebx );
		or( '0', al );
		stosb();
		
		mov( edx, eax );
		xor( edx, edx );
		mov( 100, ebx );
		div( ebx );
		or( '0', al );
		stosb();
		
		mov( edx, eax );
		xor( edx, edx );
		mov( 10, ebx );
		div( ebx );
		or( '0', al );
		stosb();
		
		mov( dl, al );
		or( '0', al );
		stosb();
		mov( 0, al );
		stosb();
		
	endif;
	  
	
	popad();
	popfd();
	pop( ebp );
	ret();
	
end e80Str;




end Int64unit;