
// I, Randall Hyde, hereby agree to waive all claim of copyright (economic
// and moral) in all content contributed by me, the user, and immediately
// place any and all contributions by me into the public domain; I grant
// anyone the right to use my work for any purpose, without any
// conditions, to be changed or destroyed in any manner whatsoever
// without any attribution or notice to the creator.  I also absolve myself
// of any responsibility for the use of this code, the user assumes all
// responsibilities for using this software in an appropriate manner.
//
// Notice of declaration of public domain, 7/12/2006, by Randall Hyde



unit ConvUnit;

#includeOnce( "../include/conversions.hhf" )
#includeOnce( "conv.hhf" )
#includeOnce( "excepts.hhf" )
#includeOnce( "strings.hhf" )


/********************************************************/
/*                                                      */
/* i32ToStr-                                            */
/*                                                      */
/* Sign extends a dword value to 64 bits and then calls */
/* the i64ToStr routine above to convert the 32-bit     */
/* integer into a string of decimal digits.             */
/*                                                      */
/********************************************************/

procedure conv.i32ToStr( d:dword; width:int32; f:char; buf:string ); 
	 @nodisplay;
	 @noframe; 
	 @noalignstack;

var
	ediSave	:dword;
	esiSave	:dword;
	edxSave	:dword;
	ecxSave	:dword;
	eaxSave	:dword;

	chars	:byte[ 32 ];	// Holds converted result w/o padding.
	
begin i32ToStr;

	push( ebp );
	mov( esp, ebp );
	sub( _vars_, esp );
	pushfd();
	cld();
	mov( eax, eaxSave );
	mov( ecx, ecxSave );
	mov( edx, edxSave );
	mov( esi, esiSave );
	mov( edi, ediSave );

	lea( edi, chars );		// Store converted digits here.
	conv.i32ToBuf( d, [edi] );

	
	// Compute the length of the string we've just generated.
	
	lea( edx, chars );
	neg( edx );
	add( edi, edx );
	
	// Determine if the result will fit into the destination buffer.
	
	mov( width, ecx );
	test( ecx, ecx );
	jns widthNotNeg;	// Negative implies left justification.
	
		neg( ecx );
		
	widthNotNeg:
	mov( edx, eax );
	cmp( edx, ecx );
	jnb ecxIsLarger;
	
		mov( ecx, eax );
		
	ecxIsLarger:
	
	mov( buf, edi );		// Get ptr to destination string.
	
	
	// If the destination string is too small, raise an exception.
	
	cmp( eax, (type str.strRec [edi]).maxlen );
	jae strOverflow;
	mov( eax, (type str.strRec[edi]).length );	// Save new string length.
	
	
	// If the width value is positive, then the number must be
	// right justified in the field width.  Output any necessary
	// leading padding characters here.
	
	cmp( width, 0 );
	jl dontRightJustify;
	
		cmp( edx, ecx );			// edx=actual chars, ecx=width
		jnb dontRightJustify;
		
			mov( f, al );		// Get the padding character.
			push( ecx );
			sub( edx, ecx );		// Computes # of padding chars to store.
			rep.stosb();
			pop( ecx );
			
		
	dontRightJustify:
	
	
	// Okay, now output the characters that make up the number.
	
	xchg( edx, ecx );
	push( ecx );
	lea( esi, chars );				// Pointer to our string.
	rep.movsb();					// Copy the chars.
	pop( ecx );
	
	
	// If the width value is negative, then the converted number
	// must be left justified in the field width.  Output any necessary
	// trailing padding characters here.
	
	cmp( width, 0 );
	jge noLeftJustify;
	
		xchg( ecx, edx );			// These were swapped, earlier.
		cmp( edx, ecx );
		jnb noLeftJustify;
		
			mov( f, al );			// Get the padding character.
			push( ecx );
			sub( edx, ecx );		// Computes # of padding chars to store.
			rep.stosb();
			pop( ecx );
			
	noLeftJustify:

	
	// Output the trailing zero terminating byte.
	
		
	mov( 0, al );
	stosb();
	
	popfd();
	mov( eaxSave, eax );
	mov( ecxSave, ecx );
	mov( edxSave, edx );
	mov( esiSave, esi );
	mov( ediSave, edi );
	leave();
	ret( _parms_ );

strOverflow:
	raise( ex.StringOverflow );

	
end i32ToStr;


end ConvUnit;
